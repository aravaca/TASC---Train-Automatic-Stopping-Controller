
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>HUD Stopping Trainer</title>
  <style>
    html,body{margin:0;background:#0b0f14;color:#e7f0ff;font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,AppleGothic,sans-serif}
    #wrap{max-width:960px;margin:18px auto;padding:0 12px}
    .row{display:flex;gap:12px;align-items:center}
    .card{background:#121826;border:1px solid #1f2a3a;border-radius:12px;padding:12px;box-shadow:0 8px 20px rgba(0,0,0,.25)}
    canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
    .kbd{background:#0a121c;border:1px solid #203048;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
    .stat{font-size:28px;font-weight:700}
    .ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
    button{background:#1a2a40;color:#e7f0ff;border:1px solid #2a446b;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:hover{background:#203652}
    #overlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.55)}
    #overlay.hide{display:none}
    @keyframes neonGlow {
      0%, 100% {
        text-shadow:
          0 0 5px #fff,
          0 0 10px #fff,
          0 0 20px currentColor,
          0 0 30px currentColor,
          0 0 40px currentColor,
          0 0 55px currentColor,
          0 0 75px currentColor;
        opacity: 1;
      }
      50% {
        text-shadow:
          0 0 2px #fff,
          0 0 5px #fff,
          0 0 10px currentColor,
          0 0 15px currentColor,
          0 0 20px currentColor,
          0 0 30px currentColor,
          0 0 40px currentColor;
        opacity: 0.8;
      }
    }

    .grade-S, .grade-A {
      animation: neonGlow 2s ease-in-out infinite;
    }

    .grade-S { color: gold; }
    .grade-A { color: #4CAF50; }

  </style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">
    <div class="card" style="flex:1 1 260px">
    <div>남은 거리 <span class="stat" id="rem">—</span> m</div>
    <div>속도 <span class="stat" id="spd">—</span> km/h</div>
    <div>노치 <span class="stat" id="notch">0.0</span></div>
    <div>경사도 <span class="stat" id="grade_percent">—</span> %</div>
    <div>경과시간 <span class="stat" id="timer">0.000</span> s</div>
    <div style="margin-top:8px">조작: <span class="kbd">Space</span> 시작 · <span class="kbd">↑</span> 브레이크 강화(노치↑) · <span class="kbd">↓</span> 완화(노치↓) · <span class="kbd">R</span> 해제</div>
  </div>

    <div class="card" style="flex:2 1 520px">
      <canvas id="hud"></canvas>
    </div>
    <div class="card" style="flex:1 1 240px">
      <div><b>피드백</b></div>
      <div id="fb">Space를 눌러 시작하세요.</div>
    </div>
  </div>
</div>

<div id="overlay">
  <div class="card" style="text-align:center">
    <div style="font-size:20px;margin-bottom:8px">정차 트레이너</div>
    <div>Space를 누르면 <b>시작</b>합니다. 초기값: 90 km/h, 500 m.</div>
    <div style="margin-top:12px"><span class="kbd">↑</span> 브레이크 강화 · <span class="kbd">↓</span> 완화 · <span class="kbd">R</span> 해제</div>
    <div style="margin-top:12px"><button id="btnStart">Start (Space)</button></div>
  </div>
</div>

<script>
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");
const remEl=document.getElementById("rem");
const spdEl=document.getElementById("spd");
const notchEl=document.getElementById("notch");
const fb=document.getElementById("fb");
const overlay=document.getElementById("overlay");
const btnStart=document.getElementById("btnStart");
const canvas=document.getElementById("hud");
const ctx=canvas.getContext("2d");
let held={up:false,down:false}, rep=null;

function resize(){
  canvas.width=canvas.clientWidth*devicePixelRatio;
  canvas.height=canvas.clientHeight*devicePixelRatio;
}
addEventListener("resize", resize); resize();

function sendCmd(name, delta) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  } else {
    console.warn("WebSocket not open yet, cmd discarded:", name, delta);
  }
}

let repInterval = null;

function startRep(){
  if(repInterval) return;
  repInterval = setInterval(() => {
    if(held.up) sendCmd("applyNotch", +1);
    if(held.down) sendCmd("applyNotch", -1);
  }, 33);
}

function stopRep(){
  if(repInterval){
    clearInterval(repInterval);
    repInterval = null;
  }
}

ws.onopen = () => {
  // 연결이 준비됐다는 표시만 하고, 시작은 키 입력으로만
  console.log("WebSocket connected");
};

btnStart.addEventListener("click", () => {
  sendCmd("start", 0);
  overlay.classList.add("hide");
});


addEventListener("keydown", (e) => {
  if ([" ", "ArrowUp", "ArrowDown", "r", "R"].includes(e.key)) e.preventDefault();
  if (e.repeat) return;  // 키 눌린 상태에서 반복 이벤트 무시

  if (e.key === " ") {
    sendCmd("start", 0);
    overlay.classList.add("hide");
  }
  else if (e.key === "ArrowUp") {
    sendCmd("applyNotch", +1);  // 딱 한번 올리기
  }
  else if (e.key === "ArrowDown") {
    sendCmd("applyNotch", -1);  // 딱 한번 내리기
  }
  else if (e.key === "r" || e.key === "R") {
    sendCmd("release", 0);
  }
});

addEventListener("keyup", (e) => {
  // 키 떼는 건 플래그나 반복과 무관하므로 특별한 처리 필요 없음
});



function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  // 축
  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr;
  ctx.beginPath(); ctx.moveTo(48*dpr,12*dpr); ctx.lineTo(48*dpr,h-28*dpr); ctx.lineTo(w-12*dpr,h-28*dpr); ctx.stroke();
  // 스케일
  const L=st.L, vmax=Math.max(st.v*1.2, st.v_ref*1.5, 25.0);
  const X=(s)=>48*dpr + (w-60*dpr)*(s/Math.max(1e-6,L));
  const Y=(v)=>(h-28*dpr) - (h-48*dpr)*(v/Math.max(1e-6,vmax));

  // v_ref 라인(표시용 샘플)
  ctx.strokeStyle="#3fa9ff"; ctx.lineWidth=2*dpr;
  ctx.beginPath();
  for(let i=0;i<=80;i++){
    const ss=L*(i/80), vv=Math.sqrt(Math.max(0, 2*(0.8*1.0)*(L-ss)));
    const x=X(ss), y=Y(vv);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // 현재 위치 점
  ctx.fillStyle="#ffd18f";
  ctx.beginPath(); ctx.arc(X(st.s), Y(st.v), 4*dpr, 0, Math.PI*2); ctx.fill();

  // 남은 거리 바
  const remRatio=Math.max(0, Math.min(1, st.remaining_m/L));
  ctx.fillStyle="#19304b"; ctx.fillRect(48*dpr, 6*dpr, (w-60*dpr), 4*dpr);
  ctx.fillStyle="#8fd0ff"; ctx.fillRect(48*dpr, 6*dpr, (w-60*dpr)*(1-remRatio), 4*dpr);
}

const grade_percentEl = document.getElementById("grade_percent");
const timerEl = document.getElementById("timer");
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type === "state") {
    const st = msg.payload;
    
    // 남은 거리 숫자 타입 보장
    const remRaw = st.remaining_m;
    const rem = typeof remRaw === "number" ? remRaw : parseFloat(remRaw);
    console.log("남은 거리 (remaining_m):", remRaw, "(parsed)", rem);

    remEl.textContent = rem >= 0
      ? rem.toFixed(2)
      : `-${Math.abs(rem).toFixed(2)}`;

    spdEl.textContent = (st.v * 3.6).toFixed(1);
    function notchText(notch) {
      if (notch === 0) return "N";
      else if (notch === 8) return "EB"; // B7 다음이 EB
      else return `B${notch}`;
    }


    // 사용 시
    notchEl.textContent = notchText(st.lever_notch, st.max_notch);


    grade_percentEl.textContent = st.grade_percent.toFixed(2);
    timerEl.textContent = st.t.toFixed(3);
    drawHUD(st);

    if (st.finished) {
      const err = st.stop_error_m || 0;
      const res = st.residual_speed_kmh || 0;
      const grade = st.grade ? st.grade.toUpperCase() : "N/A";

      // 등급에 따른 CSS 클래스 매핑
      const gradeClassMap = {
        "S": "grade-S",
        "A": "grade-A",
        "B": "grade-B",
        "C": "grade-C",
        "F": "grade-F"
      };

      const cls = gradeClassMap[grade] || "";

      fb.innerHTML = `<div class="${cls}">정지 오차: <b class="${cls}">${err.toFixed(2)} m</b></div>
                      <div class="${cls}">등급: <b class="${cls}">${grade}</b></div>
                      <div style="margin-top:8px;font-size:12px;color:#a6b7d1">Space로 다시 시작 · R 해제 · ↑/↓로 조작</div>`;
      overlay.classList.remove("hide");
      overlay.querySelector("div.card > div").textContent = "결과";
    } else {
      fb.textContent = "Space로 시작. ↑/↓로 브레이크 조절하세요.";
    }

  }
};

</script>
</body>
</html>