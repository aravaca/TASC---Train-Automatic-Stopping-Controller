<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Stop Trainer</title>
  <style>
    html,body{margin:0;background:#0b0f14;color:#e7f0ff;font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,AppleGothic,sans-serif}
    #wrap{max-width:960px;margin:18px auto;padding:0 12px}
    .row{display:flex;gap:12px;align-items:center}
    .card{background:#121826;border:1px solid #1f2a3a;border-radius:12px;padding:12px;box-shadow:0 8px 20px rgba(0,0,0,.25)}
    canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
    .kbd{background:#0a121c;border:1px solid #203048;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
    .stat{font-size:28px;font-weight:700}
    .ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
    button{background:#1a2a40;color:#e7f0ff;border:1px solid #2a446b;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:hover{background:#203652}
    #overlay {
      position: fixed;
      top: 50px;
      right: 20px;
      width: 320px;
      max-width: 90vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 0 15px rgba(0,0,0,0.7);
      z-index: 9999;
    }

    #overlay.hide {
      display: none;
    }
    @keyframes neonGlow {
      0%, 100% {
        text-shadow:
          0 0 5px #fff,
          0 0 10px #fff,
          0 0 20px currentColor,
          0 0 30px currentColor,
          0 0 40px currentColor,
          0 0 55px currentColor,
          0 0 75px currentColor;
        opacity: 1;
      }
      50% {
        text-shadow:
          0 0 2px #fff,
          0 0 5px #fff,
          0 0 10px currentColor,
          0 0 15px currentColor,
          0 0 20px currentColor,
          0 0 30px currentColor,
          0 0 40px currentColor;
        opacity: 0.8;
      }
    }

    .grade-S, .grade-A {
      animation: neonGlow 2s ease-in-out infinite;
    }

    .grade-S { color: gold; }
    .grade-A { color: #4CAF50; }

  </style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">
    <div class="card" style="flex:1 1 260px">
      <div id="carName" style="font-size:20px" class = "stat">차량 로딩 중...</div>
      <div>남은 거리 <span class="stat" id="rem">—</span> m</div>
      <div>속도 <span class="stat" id="spd">—</span> km/h</div>
      <div>노치 <span class="stat" id="notch">0.0</span></div>
      <div>경사도 <span class="stat" id="grade_percent">—</span> %</div>
      <div>경과시간 <span class="stat" id="timer">0.000</span> s</div>
      <div style="margin-top:8px">조작: <span class="kbd">Space</span> 시작 · <span class="kbd">W</span> 브레이크 강화(노치↑) · <span class="kbd">S</span> 완화(노치↓) · <span class="kbd">N</span> 해방</div>
    </div>

    <div class="card" style="flex:2 1 520px">
      <canvas id="hud"></canvas>
    </div>
    <div class="card" style="flex:1 1 240px">
      <div><b>피드백</b></div>
      <div id="fb">Space를 눌러 시작하세요.</div>
    </div>
  </div>
</div>

<div id="overlay">
  <div class="card" style="text-align:center">
    <div style="font-size:20px;margin-bottom:8px">정차 트레이너</div>
    <div>초기값을 입력하고 <b>Space</b> 또는 아래 버튼을 눌러 시작하세요.</div>
    <div style="margin-bottom:12px">
      <label>초기 속도 (km/h): <input id="inputSpeed" type="number" value="90" min="40" max="120" step="10"></label>
    </div>
    <div style="margin-bottom:12px">
      <label>거리 (m): <input id="inputDist" type="number" value="500" min="200" max="800" step="100"></label>
    </div>
    <div style="margin-bottom:12px">
      <label>경사도 (%): <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1"></label>
    </div>
    <div style="margin-top:12px"><span class="kbd">W</span> 브레이크 강화 · <span class="kbd">S</span> 완화 · <span class="kbd">N</span> 해방</div>
    <div style="margin-top:12px"><button id="btnStart">Start (Space)</button></div>
  </div>
</div>


<script>
fetch('static/carName.json')
  .then(res => res.json())
  .then(data => {
    document.getElementById('carName').textContent = data.name;
  })
  .catch(console.error);


const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");
const remEl=document.getElementById("rem");
const spdEl=document.getElementById("spd");
const notchEl=document.getElementById("notch");
const fb=document.getElementById("fb");
const overlay=document.getElementById("overlay");
const btnStart=document.getElementById("btnStart");
const canvas=document.getElementById("hud");
const ctx=canvas.getContext("2d");

function resize(){
  canvas.width=canvas.clientWidth*devicePixelRatio;
  canvas.height=canvas.clientHeight*devicePixelRatio;
}
addEventListener("resize", resize); resize();

function sendCmd(name, delta) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}
const inputSpeed = document.getElementById("inputSpeed");
const inputDist = document.getElementById("inputDist");
const inputGrade = document.getElementById("inputGrade");
btnStart.addEventListener("click", () => {
  const speed = Number(inputSpeed.value);
  const dist = Number(inputDist.value);
  const grade = Number(inputGrade.value);

  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "cmd",
      payload: {
        name: "setInitial",
        speed,
        dist,
        grade,
      }
    }));
  }

  sendCmd("start", 0);
  overlay.classList.add("hide");
});
addEventListener("keydown", (e) => {
  if ([" ", "w", "W", "s", "S", "n", "N"].includes(e.key)) e.preventDefault();
  if (e.repeat) return;

  if (e.key === " ") {
    if (ws.readyState === WebSocket.OPEN) {
      const speed = Number(inputSpeed.value);
      const dist = Number(inputDist.value);
      const grade = Number(inputGrade.value);

      ws.send(JSON.stringify({
        type: "cmd",
        payload: {
          name: "setInitial",
          speed,
          dist,
          grade,
        }
      }));
      ws.send(JSON.stringify({
        type: "cmd",
        payload: {
          name: "start"
        }
      }));
    }
    overlay.classList.add("hide");
  }
  else if (e.key === "w" || e.key === "W") {
    sendCmd("applyNotch", +1);
  }
  else if (e.key === "s" || e.key === "S") {
    sendCmd("applyNotch", -1);
  }
  else if (e.key === "n" || e.key === "N") {
    sendCmd("release", 0);
  }
});

if (/Mobi|Android/i.test(navigator.userAgent)) {
  window.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    const touch = e.touches[0];
    const y = touch.clientY;
    const h = window.innerHeight;

    if (y < h / 2) {
      sendCmd("applyNotch", +1);
    } else {
      sendCmd("applyNotch", -1);
    }
    e.preventDefault();
  }, { passive: false });
}


function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr;
  ctx.beginPath(); ctx.moveTo(48*dpr,12*dpr); ctx.lineTo(48*dpr,h-28*dpr); ctx.lineTo(w-12*dpr,h-28*dpr); ctx.stroke();

  const L=st.L, vmax=Math.max(st.v*1.2, st.v_ref*1.5, 25.0);
  const X=(s)=>48*dpr + (w-60*dpr)*(s/Math.max(1e-6,L));
  const Y=(v)=>(h-28*dpr) - (h-48*dpr)*(v/Math.max(1e-6,vmax));

  ctx.strokeStyle="#3fa9ff"; ctx.lineWidth=2*dpr;
  ctx.beginPath();
  for(let i=0;i<=80;i++){
    const ss=L*(i/80), vv=Math.sqrt(Math.max(0, 2*(0.8*1.0)*(L-ss)));
    const x=X(ss), y=Y(vv);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.fillStyle="#ffd18f";
  ctx.beginPath(); ctx.arc(X(st.s), Y(st.v), 4*dpr, 0, Math.PI*2); ctx.fill();

  const remRatio=Math.max(0, Math.min(1, st.remaining_m/L));
  ctx.fillStyle="#19304b"; ctx.fillRect(48*dpr, 6*dpr, (w-60*dpr), 4*dpr);
  ctx.fillStyle="#8fd0ff"; ctx.fillRect(48*dpr, 6*dpr, (w-60*dpr)*(1-remRatio), 4*dpr);
}

const grade_percentEl = document.getElementById("grade_percent");
const timerEl = document.getElementById("timer");
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type === "state") {
    const st = msg.payload;

    // 남은 거리 숫자 타입 보장
    const remRaw = st.remaining_m;
    const rem = typeof remRaw === "number" ? remRaw : parseFloat(remRaw);

    remEl.textContent = rem >= 0
      ? rem.toFixed(2)
      : `-${Math.abs(rem).toFixed(2)}`;

    spdEl.textContent = (st.v * 3.6).toFixed(1);
    function notchText(notch) {
      if (notch === 0) return "N";
      else if (notch === 8) return "EB"; 
      else return `B${notch}`;
    }
    notchEl.textContent = notchText(st.lever_notch);

    grade_percentEl.textContent = st.grade_percent.toFixed(2);
    timerEl.textContent = st.t.toFixed(3);
    drawHUD(st);

    if (st.finished) {
      const issues = st.issues || {};

      const feedbackItems = [
        { key: "early_brake_too_short", goodText: "초기 제동을 수행함 - 승차감 양호", badText: "초기 제동을 게을리함 - 승차감 불쾌" },
        {
          key: "stop_not_b1",
          goodText: "정차 시 B1로 정차함 - 승차감 양호",
          badTextFunc: (issues) => issues.stop_not_b1_msg || "정차 시 B1로 정차하지 않음",
        },
        {
          key: "step_brake_incomplete",
          goodText: "기본제동 (계단제동/완해) 수행함",
          badTextFunc: (issues) => {
            const overrun = issues.stop_error_m !== undefined && issues.stop_error_m <= -2;
            if (issues.stop_error_m !== undefined && issues.stop_error_m <= -2) {
              return "기본제동 (계단제동/완해) 미흡 - 오버런";
            }
            return "기본제동 (계단제동/완해) 미흡 - 단속적인 제동으로 인한 승객 쏠림 및 차량 진동 발생";
          },
        },
        { key: "unnecessary_eb_usage", goodText: "EB 미사용 - 정상 제동범위 가용", badText: "불필요한 EB 사용 - 급쏠림 현상 발생" },
      ];

      // 중복 제거: feedbacks를 한 번만 만듭니다
      const feedbacks = feedbackItems.map(item => {
        const bad = issues[item.key];
        if (!bad) {
          return { text: item.goodText, isGood: true };
        } else {
          const badText = item.badTextFunc ? item.badTextFunc(issues) : item.badText;
          return { text: badText, isGood: false, isBad: true };
        }
      });

      const isStopErrorGood = Math.abs(st.stop_error_m || 0) <= 2;

      feedbacks.push({
        text: `정지 오차: ${st.stop_error_m.toFixed(2)} m`,
        isGood: isStopErrorGood,
      });

      feedbacks.push({
        text: `최종 점수: ${st.score}점`,
        isGood: isStopErrorGood,
      });

    
      fb.innerHTML = feedbacks
        .map(item => {
          if (item.isBad) {
            return `<div class="bad">${item.text}</div>`;
          }
          return `<div class="${item.isGood ? "ok" : "warn"}">${item.text}</div>`;
        })
        .join("") + `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">Space로 다시 시작 · N 해방 · W/S로 조작</div>`;

      setTimeout(() => {
        overlay.classList.remove("hide");
        overlay.querySelector("div.card > div").textContent = "결과";
      }, 2000);
    } else {
      fb.textContent = "Space로 시작. W/S로 브레이크 조절하세요.";
    }

  }
};
</script>
</body>
</html>
