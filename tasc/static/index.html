<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
<!-- Google Fonts: Noto Sans JP Bold -->
  <link href="https://fonts.cdnfonts.com/css/a-otf-shin-go-pro" rel="stylesheet">
<style>

@import url('https://fonts.cdnfonts.com/css/a-otf-shin-go-pro');

html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}
.game-background,.snow-background,.rain-background{background:transparent!important}
#wrap{max-width:960px;margin:18px auto;padding:0 12px}
.row{display:flex;gap:12px;align-items:center}
.card{
  background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.15);border-radius:16px;padding:16px;
  backdrop-filter:blur(10px);box-shadow:0 8px 24px rgba(0,0,0,.5);transition:transform .2s,box-shadow .2s
}
.card:hover{transform:translateY(-2px);box-shadow:0 12px 28px rgba(0,0,0,.7)}
canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
.kbd{background:rgba(10,18,28,.8);border:1px solid #2b3f5f;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
.stat{font-size:32px;font-weight:800;color:#fff;text-shadow:0 0 4px rgba(0,200,255,.8)}
.ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
button,.btn-primary{background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;border-radius:12px;padding:10px 16px;font-size:15px;font-weight:600;transition:.3s background,.1s transform}
button:hover,.btn-primary:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateY(-1px)}
#overlay{
  position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);
  backdrop-filter:blur(8px);z-index:9999;overflow-y:auto;-webkit-overflow-scrolling:touch
}
#overlay.hide{display:none}
#overlay .card{max-height:90vh;overflow-y:auto}
.title{font-size:1.4rem;font-weight:600;margin-bottom:4px;color:#00f6ff}
.subtitle{font-size:.9rem;color:#9fc5ff;margin-bottom:16px}
.form-label{display:block;font-size:.85rem;margin-bottom:12px;text-align:left;font-weight:500;color:#cceaff}
.form-input{width:100%;box-sizing:border-box;padding:8px 10px;font-size:.9rem;border:1px solid rgba(0,246,255,.3);border-radius:8px;margin-top:4px;background:rgba(10,18,28,.6);color:#e7f0ff}
.form-input:focus{border-color:#00f6ff;outline:none}
@keyframes snow{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
.snowflakes,.raindrops{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;display:none;overflow:hidden}
.snowflakes div{position:absolute;background:#fff;width:10px;height:10px;border-radius:50%;opacity:.8;animation:snow 5s linear infinite}
.raindrops{z-index:9998}
.raindrops div{position:absolute;background:rgba(173,216,230,.8);width:2px;height:15px;animation:rain .5s linear infinite}
@keyframes rain{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
body{overflow-x:hidden;overflow-y:auto}
@media (max-width:768px){html,body{height:100%}body{-webkit-overflow-scrolling:touch}#wrap{padding-bottom:96px}canvas#hud{height:42vh}}
/* 재시작 FAB – 최상단, 클릭 확실하게 */
.fab{
  position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 18px;font-weight:700;border-radius:999px;
  background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;z-index:10001; /* ↑ 최상위 */
  box-shadow:0 8px 24px rgba(0,0,0,.35);cursor:pointer;pointer-events:auto
}
.fab.hide{display:none}
.fab:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateX(-50%) translateY(-1px)}
.mobile-control-guide{display:none;font-size:14px;color:#9fc5ff;background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.2);padding:8px 12px;border-radius:8px;margin-bottom:12px}
@media (max-width:768px){.mobile-control-guide{display:block}}
/* TASC 토글 – 살짝 아래 */
.tasc-toggle {
  position: absolute;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 1001;
  top: 40px; /* 기본값 = 데스크톱 */
}

/* 모바일 전용 (화면폭 768px 이하) */
@media (max-width: 768px) {
  .tasc-toggle {
    top: 165px;
  }
}
.tasc-toggle .tasc-label{font-size:12px;font-weight:600;color:#9fc5ff;user-select:none}
.tasc-toggle input{display:none}
.tasc-toggle .slider{position:relative;display:inline-block;width:46px;height:24px;background:rgba(255,255,255,.25);border-radius:24px;cursor:pointer;transition:background-color .3s;box-shadow:inset 0 0 4px rgba(0,0,0,.3)}
.tasc-toggle .slider::before{content:"";position:absolute;height:18px;width:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:transform .3s;box-shadow:0 1px 3px rgba(0,0,0,.4)}
.tasc-toggle input:checked + .slider{background:linear-gradient(135deg,#00c6ff,#0072ff)}
.tasc-toggle input:checked + .slider::before{transform:translateX(22px)}


.emoji {
  width: 1.4em;
  height: 1.4em;
  vertical-align: middle;
  transition: transform 0.2s;
}
.emoji:hover {
  transform: scale(1.3);
}

.title {
 
  font-size: 1.7em;
  font-family: 'A-OTF Shin Go Pro', sans-serif;
  font-style: normal;
  font-weight: 700;
  color: #0168B7; /* JR-West Blue */
  display: flex;
  align-items: center;
  gap: 8px; /* 아이콘과 텍스트 간격 */
}


</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">
    <div class="mobile-control-guide">
      📱 <b>모바일 조작 안내:</b> 캔버스(그래프) 위를 터치하세요.<br>
      위쪽 터치 → 브레이크 강화 🔼 / 아래쪽 터치 → 완화 🔽<br>
정차 후 아래 화면에서 피드백을 확인하세요.
    </div>

    <div class="card" style="flex:1 1 260px; position: relative">
      <div id="carName" style="font-size:20px; font-family: 'A-OTF Shin Go Pro', sans-serif;
  font-style: normal;" class="stat">차량 로딩 중...</div>
      <div>남은 거리 <span class="stat" id="rem">—</span> m</div>
      <div>속도 <span class="stat" id="spd">—</span> km/h</div>
      <div>노치 <span class="stat" id="notch">0.0</span></div>
      <div>구배 <span class="stat" id="grade_percent">—</span> ‰</div>
      <div>경과시간 <span class="stat" id="timer">0.000</span> s</div>
      <div style="margin-top:8px">조작: <span class="kbd">Space</span> 시작 · <span class="kbd">W</span> 강화 · <span class="kbd">S</span> 완화 · <span class="kbd">N</span> 해방</div>

<canvas id="brakeLadder"
          style="position:absolute; right:10px; top:12px; width:28px; height:70%;"></canvas>

    </div>

    <div class="card" style="flex:2 1 520px"><canvas id="hud"></canvas></div>
    <div class="card" style="flex:1 1 240px"><div><b>피드백</b></div><div id="fb">Space를 눌러 시작하세요.</div></div>
  </div>
</div>

<!-- 오버레이 -->
<div id="overlay">
  <div class="card">
    

  <h2 class="title">
    <img src="./Screenshot_20250815_220422_Brave(1).png" alt="E233" class="emoji"> 
    JR TASC Simulator
  </h2>


    <p class="subtitle">초기값 입력 후 <b>TASC(자동정차)</b> 설정하고 <b>Space</b> 또는 아래 버튼으로 시작하세요. TASC가 활성화된 상태에서도, 운전자는 수동 조작으로 운전에 개입할 수 있습니다.</p>

<!-- TASC -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label" style="font-weight:700">TASC</span>
    </div>

    <!-- 전동차 / 시리즈 -->
    <label class="form-label">전동차
      <select id="trainFamily" class="form-input">
  <option value="E233" selected>E233계</option>
  <option value="E235">E235계</option>
  <option value="JRW223">223계</option>
  <option value="JRW225">225계</option>
  <option value="JRH261">261계</option>
  <option value="JRW285">285계</option>
  <option value="JRW323">323계</option>
</select>
    </label>
    <label class="form-label">시리즈
      <select id="trainSeries" class="form-input"></select>
    </label>

    <label class="form-label">초기 속도 (km/h)
      <input id="inputSpeed" type="number" value="70" min="10" max="130" step="1" class="form-input">
    </label>
    <label class="form-label">거리 (m)
      <input id="inputDist" type="number" value="300" min="10" max="900" step="1" class="form-input">
    </label>
    <label class="form-label">경사도 (‰)
      <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1" class="form-input">
    </label>

    <label class="form-label">날씨
      <select id="weatherSelect" class="form-input">
        <option value="맑음">맑음</option><option value="비옴">비옴</option><option value="눈옴">눈옴</option>
      </select>
    </label>
    <label class="form-label">승객 탑승률 (%)
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>

    <!-- 편성 (시리즈별로만 고정 노출) -->
    <label class="form-label">편성
      <select class="form-input" id="trainLength" onchange="updateTrainLength()"></select>
    </label>

    <div class="game-background"></div>
    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay:0s;left:5%"></div><div style="animation-delay:.2s;left:15%"></div>
      <div style="animation-delay:.4s;left:25%"></div><div style="animation-delay:.6s;left:35%"></div>
      <div style="animation-delay:.8s;left:45%"></div><div style="animation-delay:1s;left:55%"></div>
      <div style="animation-delay:1.2s;left:65%"></div><div style="animation-delay:1.4s;left:75%"></div>
      <div style="animation-delay:1.6s;left:85%"></div><div style="animation-delay:1.8s;left:95%"></div>
    </div>

    <div class="kbd-info"><span class="kbd">W</span> 강화 · <span class="kbd">S</span> 완화 · <span class="kbd">N</span> 해방</div>
    <button id="btnStart" class="btn-primary" type="button" style="margin-top:8px">Start (Space)</button>
  </div>
</div>

<!-- 재시작 FAB -->
<button id="btnMobileRestart" class="fab hide" type="button">재시작</button>

<script>
/* ===== WebSocket & TASC ===== */
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");
const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
function forceManualOverride(){
  if (tascToggle.checked){
    tascToggle.checked=false;
    if (ws.readyState===WebSocket.OPEN){
      ws.send(JSON.stringify({type:"cmd",payload:{name:"setTASC",enabled:false}}));
    }
  }
}

/* ===== 날씨 이펙트 ===== */
const snowflakesContainer=document.querySelector('.snowflakes');
function generateSnowflake(){
  const s=document.createElement('div');
  s.style.animationDelay=(Math.random()*2)+'s';
  s.style.animationDuration=(Math.random()*5+5)+'s';
  s.style.left=Math.floor(Math.random()*101)+'%';
  s.style.position='absolute';s.style.top='-10px';s.style.width='10px';s.style.height='10px';s.style.backgroundColor='rgba(255,255,255,.8)';s.style.borderRadius='50%';
  snowflakesContainer.appendChild(s);
  setTimeout(()=>snowflakesContainer.removeChild(s),7000);
}
setInterval(generateSnowflake,200);


// === Haptics (모바일 전용) ===
// === Haptics (모바일 전용, 강도 상향 & 가드 & 로깅) ===
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

function canVibrate() {
  return isMobile &&
         typeof navigator.vibrate === "function" &&
         document.visibilityState === "visible";
}

function vibrate(pattern) {
  if (!canVibrate()) {
    console.debug("[haptics] blocked: mobile?", isMobile, "api?",
                  typeof navigator.vibrate, "visible?", document.visibilityState);
    return false;
  }
  const ok = navigator.vibrate(pattern);
  // 일부 브라우저는 boolean, 일부는 undefined를 반환
  console.debug("[haptics] vibrate called:", pattern, "->", ok);
  return ok !== false;
}

// 강화/완화 질감: 체감 되도록 길이 상향
function hapticForNotch(delta) {
  if (delta > 0) {
    // 강화: 짧은 이중 탭 (체감형)
    vibrate(100);
  } else if (delta < 0) {
    // 완화: 단일 짧은 탭
    vibrate(70);
  }
}

// (선택) EB 진입 시 더 강한 진동
function hapticForEB() {
  vibrate([300, 100, 300]);
}

// (권장) 콘솔에서 바로 시험 가능하도록
window.testVibrate = () => vibrate(120);



/* ===== 차량 JSON 로드 (캐시 무시) ===== */
let vehicle=null; let brakeDecels={};
const cacheBust=()=>`?v=${Date.now()}`;
fetch('./e233_0000.json'+cacheBust(),{cache:'no-store'})
  .then(r=>r.json()).then(data=>{
    vehicle=data; document.getElementById('carName').textContent=vehicle.name;
    if(vehicle.notch_accels && vehicle.notches){
      brakeDecels={}; for(let i=0;i<vehicle.notches;i++){ brakeDecels[i]=Math.abs(vehicle.notch_accels[vehicle.notches-1-i]??0); }
    }
  }).catch(console.error);

/* ===== DOM ===== */
const remEl=document.getElementById("rem"), spdEl=document.getElementById("spd"), notchEl=document.getElementById("notch"), fb=document.getElementById("fb");
const overlay=document.getElementById("overlay"), btnStart=document.getElementById("btnStart"), canvas=document.getElementById("hud"), ctx=canvas.getContext("2d");
const weatherSelect=document.getElementById("weatherSelect"), snowflakes=document.querySelector(".snowflakes"), raindrops=document.querySelector(".raindrops");
function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; } addEventListener("resize",resize); resize();

function getEbIdx(){
  const acc = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const n   = acc ? acc.length
                  : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  return Math.max(1, n - 1); // 0:N, 1..EB-1:B..., EB:마지막
}

// 기존
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}




function updateTrainLength(){ const L=document.getElementById("trainLength").value; ws.send(JSON.stringify({type:"cmd",payload:{name:"setTrainLength",length:L}})); sendLoadRate(); }
function sendLoadRate(){
  const loadRate=parseFloat(document.getElementById("inputLoadRate").value)||0;
  const trainLength=parseInt(document.getElementById("trainLength").value)||8;

ws.send(JSON.stringify({
  type: "cmd",
  payload: { 
    name: "setLoadRate", 
    loadRate: loadRate,
    length: trainLength
  }
}));
}
/* 입력 보정 */



const inputSpeed=document.getElementById("inputSpeed"), inputDist=document.getElementById("inputDist"), inputGrade=document.getElementById("inputGrade");
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function enforceInt(el,min,max){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^\d-]/g,'');}); el.addEventListener('change',()=>{let v=parseInt(el.value,10); if(isNaN(v)){el.value='';return;} el.value=String(clamp(v,min,max));});}
function enforceFloat(el,min,max,d=1){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^0-9.\-]/g,'');}); el.addEventListener('change',()=>{let v=parseFloat(el.value); if(isNaN(v)){el.value='';return;} v=clamp(v,min,max); el.value=v.toFixed(d);});}
enforceInt(inputSpeed,10,130); enforceInt(inputDist,10,900);
const inputLoadRate = document.getElementById("inputLoadRate"); // ← 추가

enforceInt(inputLoadRate,0,120); // ← 이제 에러 없음
document.getElementById("inputLoadRate").addEventListener("change",sendLoadRate); enforceFloat(inputGrade,-10,10,1);

document.getElementById("inputLoadRate").addEventListener("change",sendLoadRate);

/* 날씨 UI */
function muFromWeather(w){return w==="비옴"?0.6:(w==="눈옴"?0.3:1.0)}
function updateWeatherUI(){
  const w=weatherSelect.value, ov=document.getElementById("overlay");
  if(w==="눈옴"){snowflakes.style.display="block";raindrops.style.display="none";document.documentElement.style.background="#fff";document.body.style.background="#fff";ov.style.background="rgba(255,255,255,.15)";canvas.style.background="#fff";}
  else if(w==="비옴"){snowflakes.style.display="none";raindrops.style.display="block";document.documentElement.style.background="#4b5d67";document.body.style.background="#4b5d67";ov.style.background="rgba(40,60,80,.35)";canvas.style.background="#4b5d67";}
  else{snowflakes.style.display="none";raindrops.style.display="none";const g="radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";document.documentElement.style.background=g;document.body.style.background=g;ov.style.background="rgba(0,0,0,.6)";canvas.style.background="linear-gradient(#0b0f14,#0a1019)";}
}
weatherSelect.addEventListener("change",()=>{updateWeatherUI();const mu=muFromWeather(weatherSelect.value); if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:"cmd",payload:{name:"setMu",value:mu}}));}});
updateWeatherUI();

/* 시작/재시작 */
function startRun(){
  inputSpeed.dispatchEvent(new Event('change')); inputDist.dispatchEvent(new Event('change')); inputGrade.dispatchEvent(new Event('change'));
  const speed=Number(inputSpeed.value), dist=Number(inputDist.value), grade=Number(inputGrade.value), mu=muFromWeather(weatherSelect.value);
  if(ws.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({type:"cmd",payload:{name:"setInitial",speed,dist,grade,mu}})); ws.send(JSON.stringify({type:"cmd",payload:{name:"start"}})); }
  overlay.classList.add("hide"); isFinished=false; overlayShowingResult=false;
  btnMobileRestart.classList.add("hide");
}
btnStart.addEventListener("click", startRun);

const btnMobileRestart=document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", ()=>{
  // 혹시 오버레이가 이미 떠 있으면 중복 방지
  if(!overlay.classList.contains("hide")) overlay.classList.add("hide");
  overlay.classList.remove("hide");
  overlayShowingResult=true;
  btnMobileRestart.classList.add("hide");
});

/* 모바일 터치 조작 */
if(/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)){
  const game=document.getElementById("hud");
  game.addEventListener("touchstart",(e)=>{
    if(!overlay.classList.contains("hide")) return;
    if(e.touches.length!==1) return;
    forceManualOverride();
    const r=game.getBoundingClientRect(), y=e.touches[0].clientY-r.top, half=r.height/2;
    if(y<half){
      hapticForNotch(+1);
      sendCmd("applyNotch",+1);
    } else {
      hapticForNotch(-1);
      sendCmd("applyNotch",-1);
 }
}, { passive: true });
}

/* 키보드 */
addEventListener("keydown",(e)=>{
  if([" ","w","W","s","S","n","N"].includes(e.key)) e.preventDefault();
  if(e.repeat) return;
  forceManualOverride();
  if(e.key===" "){ if(ws.readyState!==WebSocket.OPEN) return; startRun(); }
  else if(e.key==="w"||e.key==="W"){ sendCmd("applyNotch",+1); }
  else if(e.key==="s"||e.key==="S"){ sendCmd("applyNotch",-1); }
  else if(e.key==="n"||e.key==="N"){ sendCmd("release",0); }
});

/* HUD & 상태 */
const grade_percentEl=document.getElementById("grade_percent"), timerEl=document.getElementById("timer");
let isFinished=false, overlayShowingResult=false, st=null, lastTimestamp=0, prevMaxDistance=0;
function loop(ts){ if(!lastTimestamp) lastTimestamp=ts; lastTimestamp=ts; if(st) drawHUD(st); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

ws.onmessage=(ev)=>{
  const msg=JSON.parse(ev.data);
  if(msg.type==="state"){
    st=msg.payload;
    // === PATCH: 서버에서 온 TASC 예측 저장 ===
    window.__tasc_pred__ = st.tasc_pred || {};
    const remRaw=st.remaining_m, rem=typeof remRaw==="number"?remRaw:parseFloat(remRaw);
    remEl.textContent = rem>=0 ? rem.toFixed(2) : `-${Math.abs(rem).toFixed(2)}`;
    spdEl.textContent = (st.v*3.6).toFixed(1);
    const maxIdx = (vehicle?.notches ?? 10) - 1; // EB 인덱스
notchEl.textContent =
  st.lever_notch === 0 ? "N" :
  st.lever_notch === maxIdx ? "EB" : `B${st.lever_notch}`;
    grade_percentEl.textContent = (10* st.grade_percent).toFixed(1);
    timerEl.textContent = st.t.toFixed(3);
    drawHUD(st);

    drawBrakeLadderMini(st);  // ← 미니 인디케이터 갱신

    if (st.finished) {
      isFinished = true;
      const issues = st.issues || {};

      const feedbackItems = [
        { key: "early_brake_too_short", goodText: "초기 제동을 수행함 - 승차감 양호", badText: "초기 제동을 게을리함 - 승차감 불쾌" },
        {
          key: "stop_not_b1",
          goodText: "정차 시 B1로 정차함 - 승차감 양호",
          badTextFunc: (issues) => issues.stop_not_b1_msg || "정차 시 B1로 정차하지 않음",
        },
        {
          key: "step_brake_incomplete",
          goodText: "기본제동 (계단제동/완해) 수행함",
          badTextFunc: (issues) => {
            const overrun = issues.stop_error_m !== undefined && issues.stop_error_m <= -2;
            if (issues.stop_error_m !== undefined && issues.stop_error_m <= -2) {
              return "기본제동 (계단제동/완해) 미흡 - 정차 위치 초과 및 운행 지연 발생";
            }
            return "기본제동 (계단제동/완해) 미흡 - 단속적인 제동으로 인한 승객 쏠림 및 차량 진동 발생";
          },
        },
        { key: "unnecessary_eb_usage", goodText: "영업 안전 제동범위 준수", badText: "불필요한 비상제동(EB) 사용 - 급감속으로 인한 충격 발생" },
      ];

      const feedbacks = feedbackItems.map(item => {
        const bad = issues[item.key];
        if (!bad) return { text: item.goodText, isGood: true };
        const badText = item.badTextFunc ? item.badTextFunc(issues) : item.badText;
        return { text: badText, isGood: false, isBad: true };
      });

      const isStopErrorGood = Math.abs(st.stop_error_m || 0) <= 2;

      feedbacks.push({
        text: `정지 오차: ${st.stop_error_m.toFixed(2)} m`,
        isGood: isStopErrorGood,
      });

      feedbacks.push({
        text: `최종 점수: ${st.score}점`,
        isGood: isStopErrorGood,
      });

      fb.innerHTML = feedbacks
        .map(item => item.isBad
          ? `<div class="bad">${item.text}</div>`
          : `<div class="${item.isGood ? "ok" : "warn"}">${item.text}</div>`
        )
        .join("") + `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">Space로 다시 시작 · N 해방 · W/S로 조작</div>`;

      if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
        document.getElementById("btnMobileRestart").classList.remove("hide");
      }
    } else {
      isFinished = true;
      fb.textContent = "Space로 시작. W/S로 브레이크 조절하세요.";
    }
  }
};

/* HUD 그리기 (원본 유지) */
function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const v0=st.v, lever=st.lever_notch, currentPos=st.pos??0, stopPos=st.stopPos??500;
  const remaining=(typeof st.remaining_m==="number")?Math.max(0,st.remaining_m):Math.max(0,stopPos-currentPos);
  const maxDecel=Math.max(...Object.values(brakeDecels)); const maxStop=maxDecel>0?(v0*v0)/(2*maxDecel):0;
  const speedFactor=Math.max(.3,Math.min(1,v0/10)); const adjusted=remaining*(1+(1-speedFactor)*.5);
  const s_b1=(brakeDecels[1]??0)>0?(v0*v0)/(2*brakeDecels[1]):0, s_b2=(brakeDecels[2]??0)>0?(v0*v0)/(2*brakeDecels[2]):0;
  const target=Math.max(1,maxStop*1.5,Math.max(1,Math.sqrt(adjusted)*10)*1.2,s_b1*1.1,s_b2*1.1);
  prevMaxDistance = prevMaxDistance===0 ? target : prevMaxDistance*.9 + target*.1;

  const left=48*dpr, right=12*dpr, usableW=w-left-right, X=d=>left+usableW*(d/prevMaxDistance);
  const vmax=Math.max(1,v0*3.6*1.2);
  const bottom=28*dpr, top=12*dpr, usableH=h-bottom-top, Y=v=>h-bottom-usableH*(v/vmax);

  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,h-bottom); ctx.lineTo(w-right,h-bottom); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let d=0; d<=prevMaxDistance; d+=100){ const x=X(d); ctx.beginPath(); ctx.moveTo(x,h-bottom); ctx.lineTo(x,h-bottom+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(d)}`,x,h-bottom+6*dpr); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let k=0;k<=vmax;k+=10){ const y=Y(k); ctx.beginPath(); ctx.moveTo(left-4*dpr,y); ctx.lineTo(left,y); ctx.stroke(); ctx.fillText(`${k}`,left-6*dpr,y); }



ctx.lineWidth=2*dpr; 
  const maxNotch = vehicle?.notches ?? 10;   // 총 개수(0~maxIdx)
  const maxIdx   = maxNotch - 1;  // EB 인덱스
  for(let n=0;n<maxNotch;n++){
    const a=brakeDecels[n]??0; if(a<=0) continue;
    const s=(v0*v0)/(2*a);
    ctx.beginPath(); ctx.strokeStyle = n===lever ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<=100;i++){
      const f=i/100, ds=s*f, v=Math.sqrt(Math.max(0,v0*v0-2*a*ds));
      const x=X(ds), y=Y(v*3.6); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle=n===lever?"#ffae00":"#3fa9ff"; ctx.font=`${12*dpr}px 'Orbitron', sans-serif`;
    const tX=X(s); const label = (n===0) ? "N" : (n===maxIdx ? "EB" : `B${n}`);
    ctx.fillText(label, tX+5*dpr, Y(0)+12*dpr);
  }




const xRed=X(remaining); ctx.strokeStyle="#f00"; ctx.lineWidth=1.5*dpr; ctx.beginPath(); ctx.moveTo(xRed,Y(0)); ctx.lineTo(xRed,Y(vmax)); ctx.stroke();
  ctx.fillStyle="#f00"; ctx.font=`${14*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center"; ctx.fillText("남은 거리", xRed, Y(vmax)-18*dpr);

  const ribbonW=16*dpr, ribbonH=h*.9, ribbonX=w-right-ribbonW-10*dpr+20, ribbonY=((h-ribbonH)/2)-32;
  ctx.fillStyle="rgba(100,100,100,.1)"; ctx.strokeStyle="rgba(100,100,100,.3)"; ctx.lineWidth=1.5*dpr;
  ctx.beginPath(); ctx.rect(ribbonX,ribbonY,ribbonW,ribbonH); ctx.fill(); ctx.stroke();

  const centerY=(ribbonY+ribbonH/2)-14, barH=12*dpr;
  ctx.fillStyle="rgba(60,60,60,.9)"; ctx.fillRect(ribbonX+2*dpr, centerY-barH/2, ribbonW-4*dpr, barH);

  const rem=Math.min(Math.max(st.remaining_m??st.L,-st.L), st.L);
  const diamondW=16*dpr, diamondH=10*dpr, dX=ribbonX+ribbonW/2;
  const normalized=(rem-(-7))/(7-(-7));
  const dY=ribbonY+(ribbonH*(1-normalized))-diamondH/2;
  const adjY=Math.min(Math.max(dY, ribbonY-10*dpr), ribbonY+ribbonH-diamondH+10*dpr);
  ctx.fillStyle="#444"; ctx.strokeStyle="#222"; ctx.lineWidth=2*dpr; ctx.beginPath();
  ctx.moveTo(dX, adjY-diamondH/2); ctx.lineTo(dX+diamondW/2, adjY); ctx.lineTo(dX, adjY+diamondH/2); ctx.lineTo(dX-diamondW/2, adjY);
  ctx.closePath(); ctx.fill(); ctx.stroke();


}



// 미니 인디케이터 사이즈 맞추기
const ladderCanvas = document.getElementById('brakeLadder');
function sizeLadderCanvas() {
  if (!ladderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ladderCanvas.clientWidth;
  const cssH = ladderCanvas.clientHeight;
  ladderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  ladderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeLadderCanvas);
sizeLadderCanvas();

function drawBrakeLadderMini(st) {
  const ctx2 = ladderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ladderCanvas.width, h = ladderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

  // ★ EB 위치는 notch_accels 길이로 결정 (있으면 무조건 이것만 신뢰)
  const accArr  = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const notches = accArr ? accArr.length
                         : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);

  const ebIdx   = accArr ? Math.max(1, accArr.length - 1)   // 0:N, 1~EB-1:B1.., EB:마지막
                         : Math.max(1, notches - 1);

  const blocks  = ebIdx;                   // B1..EB 표시 블록 수
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0)); // 현재 노치 클램프

  // 패널
  ctx2.fillStyle = "rgba(100,100,100,0.10)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = 2 * dpr;
  const gap  = Math.max(2 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  // 서비스 노치(노랑): B1..EB-1
  const serviceTop = Math.min(cur, ebIdx - 1);
  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;

    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);

    if (k <= serviceTop) {
      ctx2.fillStyle = "#ffd34d";          // 노란색
      ctx2.fillRect(x, y, bW, bH);
    }

    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  // EB(맨 위)는 빨강: cur===EB일 때만
  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) {
    ctx2.fillStyle = "#ff5757";            // 빨간색
    ctx2.fillRect(x, yEB, bW, bH);
  }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);
}



/* ===== 전동차/시리즈/편성: 사진 스펙 고정 ===== */
const TRAIN_DB={
  E233:[
    {code:"EAST E233-0", lines:"주오쾌속·소부쾌속", file:"./e233_0000.json", lengths:[4,6,10,12]}, // 요청대로
    {code:"EAST E233-1000", lines:"게이힌토호쿠·네기시", file:"./e233_1000.json", lengths:[10]},
    {code:"EAST E233-2000", lines:"조반 각역·쾌속", file:"./e233_2000.json", lengths:[10]},
    {code:"EAST E233-3000", lines:"도카이도·도호쿠·타카사키·우에노도쿄/소부쾌속·조반 직통", file:"./e233_3000.json", lengths:[5,10,15]},
    {code:"EAST E233-5000", lines:"게이요", file:"./e233_5000.json", lengths:[4,6,10]},
    {code:"EAST E233-6000", lines:"요코하마", file:"./e233_6000.json", lengths:[8]},
    {code:"EAST E233-7000", lines:"사이쿄·가와고에·쇼난신주쿠 일부", file:"./e233_7000.json", lengths:[10]},
    {code:"EAST E233-8000", lines:"난부", file:"./e233_8000.json", lengths:[6]}
  ],
  E235:[
    {code:"EAST E235-0", lines:"야마노테", file:"./e235_0.json", lengths:[11]},
    {code:"EAST E235-1000", lines:"요코스카·소부쾌속", file:"./e235_1000.json", lengths:[4,11]}
  ]
};

// ▼ JR-WEST : 노선명으로 교체 (사실 확인 반영)
TRAIN_DB.JRW223 = [
  // 223-0 (HE 계열: 히네노 소속)
  { code: "WEST 223-0",
    lines: "오사카 순환선 · 한와선 · 간사이공항선 직결 · 기세이 본선(기노쿠니선, 와카야마–스사미/기이타나베)",
    file: "./223_0000.json", lengths: [4] }, // 0

  // 223-1000 (V/W 편성)
  { code: "WEST 223-1000",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인) · 산요 본선(JR 고베 라인) · 호쿠리쿠 본선(쓰루가–마이바라) · 고세이선 · 구사쓰선 · 아코선",
    file: "./223_1000.json", lengths: [8,4] }, // 1

  // 223-2000 (W/B/V 편성)
  { code: "WEST 223-2000",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인) · 산요 본선(JR 고베 라인) · 호쿠리쿠 본선(쓰루가–마이바라) · 고세이선 · 구사쓰선 · 아코선",
    file: "./223_2000.json", lengths: [8,6,4] }, // 2

  // 223-2500 (HE: 히네노 / RU: 교토 두 계열이 존재 → 사진에 맞춰 2개로 분리)
  { code: "WEST 223-2500 (Hineno)",
    lines: "오사카 순환선 · 한와선 · 간사이공항선 직결 · 기세이 본선(기노쿠니선, 와카야마–스사미/기이타나베)",
    file: "./223_2500.json", lengths: [4] }, // 3
  { code: "WEST 223-2500 (Kyoto)",
    lines: "도카이도 본선(비와코 라인, 야마시나–교토) · 고세이선(야마시나–나가하라) · 산인 본선(사가노선, 교토–고마)",
    file: "./223_2500.json", lengths: [4] }, // 4

  // 223-6000 (PR/MA 편성: 감속 제한형, 소속별 운용 구간 상이)
  { code: "WEST 223-6000",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인) · 산요 본선(JR 고베 라인) · 반탄선(히메지–테라마에 일부 대체) · 아코선 / (미하라 소속) JR 고베선(오사카–아마가사키) · 후쿠치야마선(아마가사키–사사야마구치/후쿠치야마)",
    file: "./223_6000.json", lengths: [4,6] } // 5
];

TRAIN_DB.JRW225 = [
  // 225-0 / 100 : 신쾌속 축
  { code: "WEST 225-0",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인, 마이바라–고베) · 산요 본선(JR 고베 라인, 고베–카미고리) · 호쿠리쿠 본선(쓰루가–마이바라) · 고세이선 · 구사쓰선 · 아코선",
    file: "./225_0000.json", lengths: [4,8] }, // 6
  { code: "225-100",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인, 마이바라–고베) · 산요 본선(JR 고베 라인, 고베–카미고리) · 호쿠리쿠 본선(쓰루가–마이바라) · 고세이선 · 구사쓰선 · 아코선",
    file: "./225_0100.json", lengths: [4,6,8] }, // 7
  { code: "WEST 225-700",
    lines: "도카이도 본선(비와코·JR 교토·JR 고베 라인, 야스–고베) · 산요 본선(JR 고베 라인, 아보시–고베)",
    file: "./225_0700.json", lengths: [4] }, // 8

  // 225-5000/5100 : 공항·한와·순환선 중심
  { code: "WEST 225-5000",
    lines: "오사카 순환선 · 한와선(간사이공항선 직결) · 간사이공항선 · 기세이 본선(기노쿠니선, 와카야마–기이타나베)",
    file: "./225_5000.json", lengths: [4] }, // 9
  { code: "WEST 225-5100 (4량)",
    lines: "오사카 순환선 · 한와선(간사이공항선 직결) · 간사이공항선 · 기세이 본선(기노쿠니선, 와카야마–기이타나베)",
    file: "./225_5100.json", lengths: [4] }, // 10
  { code: "WEST 225-5100 (6량)",
    lines: "한와선",
    file: "./225_5100.json", lengths: [6] }, // 11

  // 225-6000 : 성능 제한형(후쿠치야마 방면)
  { code: "WEST 225-6000",
    lines: "JR 고베선(오사카–아마가사키) · 후쿠치야마선(JR 타카라즈카선, 아마가사키–사사야마구치/후쿠치야마)",
    file: "./225_6000.json", lengths: [6,4] } // 12
];

TRAIN_DB.JRW323 = [
  { code: "WEST 323-0",
    lines: "오사카 순환선 전용",
    file: "./323_0000.json", lengths: [8] } // 13
];

TRAIN_DB.JRW285 = [
  { code: "WEST 285-0/3000",
    lines: "침대특급 선라이즈 이즈모·세토 전용",
    file: "./285.json",
    lengths: [7, 14] } // 7량편성, 병결 시 14량편성
];

TRAIN_DB.JRH261 = [
  { code: "HOKKAIDO KiHa 261-5000",
    lines: "조이풀 트레인 하마나스·라벤더",
    file: "./261_5000.json",
    lengths: [4, 5, 6, 10] } // 5량 기본, 10량 병결
];

const trainFamilyEl=document.getElementById('trainFamily');
const trainSeriesEl=document.getElementById('trainSeries');
const trainLengthEl=document.getElementById('trainLength');

function setTrainLengthOptions(lengths){
  trainLengthEl.innerHTML="";
  lengths.forEach(len=>{
    const opt=document.createElement('option');
    opt.value=String(len); opt.textContent=`${len}량`;
    trainLengthEl.appendChild(opt);
  });
  updateTrainLength();
}


function loadVehicleFile(filePath){
  fetch(filePath + cacheBust(), { cache: 'no-store' })
    .then(res => res.json())
    .then(data => {
      vehicle = data;
      vehicle.notches = (vehicle.notch_accels || []).length;  // EB 동기화
      document.getElementById('carName').textContent = vehicle.name;

      brakeDecels = {};
      if (vehicle.notch_accels && vehicle.notches) {
        for (let i = 0; i < vehicle.notches; i++) {
          brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
        }
      }

      // 서버 vehicle 교체
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setVehicleFile", file: filePath } }));
      }

      sendLoadRate();
    })
    .catch(console.error);
}

function populateSeries(){
  const fam=trainFamilyEl.value, list=TRAIN_DB[fam]||[];
  trainSeriesEl.innerHTML="";
  list.forEach((s,i)=>{
    const opt=document.createElement('option');
    opt.value=s.file; opt.dataset.lengths=JSON.stringify(s.lengths);
    opt.textContent=`JR ${s.code} (${s.lines})`;
    if(i===0) opt.selected=true;
    trainSeriesEl.appendChild(opt);
  });
  if(list[0]){ setTrainLengthOptions(list[0].lengths); loadVehicleFile(list[0].file); }
}
trainFamilyEl.addEventListener('change', populateSeries);
trainSeriesEl.addEventListener('change',(e)=>{
  const opt=e.target.selectedOptions[0];
  const lengths=JSON.parse(opt.dataset.lengths||"[]");
  setTrainLengthOptions(lengths);
  loadVehicleFile(opt.value);
});
populateSeries(); // 최초 세팅
</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  ©2025 Hyungsuk Choi, University of Maryland
</footer>
</body>
</html>
