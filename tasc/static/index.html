<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
  <!-- Google Fonts: Noto Sans JP Bold -->
  <link href="https://fonts.cdnfonts.com/css/a-otf-shin-go-pro" rel="stylesheet">
<style>
@import url('https://fonts.cdnfonts.com/css/a-otf-shin-go-pro');

html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}
.game-background,.snow-background,.rain-background{background:transparent!important}
#wrap{max-width:960px;margin:18px auto;padding:0 12px}
.row{display:flex;gap:12px;align-items:center}
.card{
  background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.15);border-radius:16px;padding:16px;
  backdrop-filter:blur(10px);box-shadow:0 8px 24px rgba(0,0,0,.5);transition:transform .2s,box-shadow .2s
}
.card:hover{transform:translateY(-2px);box-shadow:0 12px 28px rgba(0,0,0,.7)}
canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
.kbd{background:rgba(10,18,28,.8);border:1px solid #2b3f5f;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
.stat{font-size:32px;font-weight:800;color:#fff;text-shadow:0 0 4px rgba(0,200,255,.8)}
.ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
button,.btn-primary{background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;border-radius:12px;padding:10px 16px;font-size:15px;font-weight:600;transition:.3s background,.1s transform}
button:hover,.btn-primary:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateY(-1px)}
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.6);
  backdrop-filter: blur(8px);
  z-index: 9999;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

/* 💻 데스크탑 전용 (768px 초과 시) */
@media (min-width: 769px) {
  #overlay {
    inset: auto;       /* 전체 덮는 대신 */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;

    justify-content: center;
    align-items: flex-start;
    padding-top: 40px; /* 살짝 여백 */
  }
  #overlay .card {
    width: 720px;      /* 원하는 fixed width */
    max-height: 90vh;  /* 세로는 스크롤 허용 */
  }
}

#overlay.hide{display:none}
#overlay .card{max-height:90vh;overflow-y:auto}
.title{font-size:1.4rem;font-weight:600;margin-bottom:4px;color:#00f6ff}
.subtitle{font-size:.9rem;color:#9fc5ff;margin-bottom:16px}
.form-label{display:block;font-size:.85rem;margin-bottom:12px;text-align:left;font-weight:500;color:#cceaff}
.form-input{width:100%;box-sizing:border-box;padding:8px 10px;font-size:.9rem;border:1px solid rgba(0,246,255,.3);border-radius:8px;margin-top:4px;background:rgba(10,18,28,.6);color:#e7f0ff}
.form-input:focus{border-color:#00f6ff;outline:none}
@keyframes snow{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
.snowflakes,.raindrops{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;display:none;overflow:hidden}
.snowflakes div{position:absolute;background:#fff;width:10px;height:10px;border-radius:50%;opacity:.8;animation:snow 5s linear infinite}
.raindrops{z-index:9998}
.raindrops div{position:absolute;background:rgba(173,216,230,.8);width:2px;height:15px;animation:rain .5s linear infinite}
@keyframes rain{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
body{overflow-x:hidden;overflow-y:auto}
@media (max-width:768px){html,body{height:100%}body{-webkit-overflow-scrolling:touch}#wrap{padding-bottom:96px}canvas#hud{height:42vh}}
/* 재시작 FAB – 최상단, 클릭 확실하게 */
.fab{
  position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 18px;font-weight:700;border-radius:999px;
  background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;z-index:10001;
  box-shadow:0 8px 24px rgba(0,0,0,.35);cursor:pointer;pointer-events:auto
}
.fab.hide{display:none}
.fab:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateX(-50%) translateY(-1px)}
.mobile-control-guide{display:none;font-size:14px;color:#9fc5ff;background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.2);padding:8px 12px;border-radius:8px;margin-bottom:12px}
@media (max-width:768px){.mobile-control-guide{display:block}}
/* TASC 토글 – 살짝 아래 */
.tasc-toggle {
  position: absolute;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 1001;
  top: 40px;
}
@media (max-width: 768px) {.tasc-toggle {top: 165px;}}
.tasc-toggle .tasc-label{font-size:12px;font-weight:600;color:#9fc5ff;user-select:none}
.tasc-toggle input{display:none}
.tasc-toggle .slider{position:relative;display:inline-block;width:46px;height:24px;background:rgba(255,255,255,.25);border-radius:24px;cursor:pointer;transition:background-color .3s;box-shadow:inset 0 0 4px rgba(0,0,0,.3)}
.tasc-toggle .slider::before{content:"";position:absolute;height:18px;width:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:transform .3s;box-shadow:0 1px 3px rgba(0,0,0,.4)}
.tasc-toggle input:checked + .slider{background:linear-gradient(135deg,#00c6ff,#0072ff)}
.tasc-toggle input:checked + .slider::before{transform:translateX(22px)}

.emoji { width: 1.4em; height: 1.4em; vertical-align: middle; transition: transform 0.2s;}
.emoji:hover { transform: scale(1.3);}

.title { font-size: 1.7em; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; color: #0168B7; display: flex; align-items: center; gap: 8px;}

.line {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin: 4px 0;
}
.line .value {
  text-align: right;
  padding-right: 40px;  /* 👈 오른쪽에 여백 주기 (라더캔버스+간격) */
  min-width: 100px;     /* 👈 숫자 칸 최소 너비 잡아주면 더 안정적 */
}
.line .unit {
  margin-left: 4px;
  opacity: 0.8;
  font-size: 14px;
  letter-spacing:-2px;
}

#timer {
  letter-spacing: 0px; /* 숫자 간격 약간 넓히기 */
}

@media (max-width:768px){
  .line .value { padding-right: 50px; }
}
</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

 <!--   <div class="mobile-control-guide" id="mobileGuide">
      📱 <b>모바일 조작 안내:</b> 캔버스(그래프) 위를 터치하세요.<br>
      위쪽 터치 → 브레이크 강화 🔼 / 아래쪽 터치 → 완화 🔽<br>
      정차 후 아래 화면에서 피드백을 확인하세요.
    </div> -->

<div class="card" style="flex:1 1 260px; position: relative">
  <div id="carName" style="font-size:20px; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal;" class="stat">차량 로딩 중...</div>

 <div class="line">
  <span id="labelRemainTime">남은시간</span>
  <span class="stat value" id="timer">0 s</span>
</div>
<div class="line">
  <span id="labelSpeed">속도</span>
  <span class="stat value"><span id="spd">—</span><span class="unit"> km/h</span></span>
</div>
<div class="line">
  <span id="labelRemainDist">정차</span>
  <span class="stat value" id="rem">—</span>
</div>
<div class="line">
  <span id="labelGrade">구배</span>
  <span class="stat value"><span id="grade_percent">—</span><span class="unit"> ‰</span></span>
</div>
<div class="line">
  <span id="labelNotch">제동</span>
  <span class="stat value" id="notch">-</span>
</div>
  <div style="margin-top:8px">
    <span id="labelControls">조작:</span>
    <span class="kbd">Space</span> <span id="labelStartKey">시작</span> ·
    <span class="kbd">W</span> <span id="labelUp">강화</span> ·
    <span class="kbd">S</span> <span id="labelDown">완화</span> ·
    <span class="kbd">N</span> <span id="labelRelease">해방</span>
  </div>

  <canvas id="brakeLadder" style="position:absolute; right:10px; top:30px; width:28px; height:70%;"></canvas>
</div>

<div class="card" style="flex:2 1 520px"><canvas id="hud"></canvas></div>
<div class="card" style="flex:1 1 240px"><div><b>피드백</b></div><div id="fb">Space로 시작. W/S로 브레이크 조절하세요.</div></div>
</div>
</div>

<!-- 오버레이 -->
<div id="overlay">
  <div class="card">
    <h2 class="title">
      <img src="./Screenshot_20250815_220422_Brave(1).png" alt="E233" class="emoji"> 
      JR TASC Simulator
    </h2>

    <p class="subtitle" id="subtitleIntro">초기값 입력 후 <b>TASC(자동정차)</b> 설정하고 <b>Space</b> 또는 아래 버튼으로 시작하세요. TASC가 활성화된 상태에서도, 운전자는 수동 조작으로 운전에 개입할 수 있습니다.</p>

    <!-- TASC -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label" id="labelTASC" style="font-weight:700">TASC</span>
    </div>

    <!-- 전동차 / 시리즈 -->
    <label class="form-label"><span id="labelTrain">전동차</span>
      <select id="trainFamily" class="form-input">
        <option value="E233" selected>E233계</option>
        <option value="E235">E235계</option>
        <option value="JRW223">223계</option>
        <option value="JRW225">225계</option>
        <option value="JRH261">261계</option>
        <option value="JRW285">285계</option>
        <option value="JRW323">323계</option>
        <option value="JR103">103계</option>
        <option value="EF510">EF510형 전기기관차 + E26계 객차</option>
        <option value="K3000">케이세이 3000계</option>
        <option value="T5300">도쿄도 교통국 5300계</option>
      </select>
    </label>
    <label class="form-label"><span id="labelSeries">시리즈</span>
      <select id="trainSeries" class="form-input"></select>
    </label>

    <!-- ✅ 속도/거리 입력 범위 갱신: 속도 40~130, 거리 150~900 -->
    <label class="form-label"><span id="labelInitSpeed">초기 속도 (km/h)</span>
      <input id="inputSpeed" type="number" value="70" min="40" max="130" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelInitDist">거리 (m)</span>
      <input id="inputDist" type="number" value="300" min="150" max="900" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelGradeInput">경사도 (‰)</span>
      <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1" class="form-input">
    </label>

    <label class="form-label"><span id="labelWeather">날씨</span>
      <select id="weatherSelect" class="form-input">
        <option value="맑음">맑음</option><option value="비옴">우천</option><option value="눈옴">강설/빙판</option>
      </select>
    </label>
    <label class="form-label"><span id="labelLoadRate">승객 탑승률 (%)</span>
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>

    <!-- 편성 (시리즈별로만 고정 노출) -->
    <label class="form-label"><span id="labelTrainLength">편성</span>
      <select class="form-input" id="trainLength" onchange="updateTrainLength()"></select>
    </label>

    <div class="game-background"></div>
    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay:0s;left:5%"></div><div style="animation-delay:.2s;left:15%"></div>
      <div style="animation-delay:.4s;left:25%"></div><div style="animation-delay:.6s;left:35%"></div>
      <div style="animation-delay:.8s;left:45%"></div><div style="animation-delay:1s;left:55%"></div>
      <div style="animation-delay:1.2s;left:65%"></div><div style="animation-delay:1.4s;left:75%"></div>
      <div style="animation-delay:1.6s;left:85%"></div><div style="animation-delay:1.8s;left:95%"></div>
    </div>

    <div class="kbd-info"><span class="kbd">W</span> 강화 · <span class="kbd">S</span> 완화 · <span class="kbd">N</span> 해방</div>
    <button id="btnStart" class="btn-primary" type="button" style="margin-top:8px">Start (Space)</button>
  </div>
</div>

<!-- 재시작 FAB -->
<button id="btnMobileRestart" class="fab hide" type="button">재시작</button>

<script>
/* ===== WebSocket & TASC ===== */
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

ws.addEventListener('open', () => {
  // ✅ 보정표(IDW) 한 번만 세팅하면 이후 자동 제한시간 산출
  ws.send(JSON.stringify({
    type: "cmd",
    payload: {
      name: "setTimerCalib",
      points: [
        { v: 40, L: 150, t: 27 },
        { v: 60, L: 200, t: 29 },
        { v: 70, L: 300, t: 32 },
        { v: 90, L: 500, t: 40 },
        { v: 130, L: 900, t: 49 }
      ],
      norm_v: 100,
      norm_L: 300,
      idw_power: 2.0,
      blend_threshold: 1.5
    }
  }));
  // 타이머 활성화
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "toggleTimer", enabled: true } }));
});

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
// function forceManualOverride(){
//   if (tascToggle.checked){
//     tascToggle.checked=false;
//     if (ws.readyState===WebSocket.OPEN){
//       ws.send(JSON.stringify({type:"cmd",payload:{name:"setTASC",enabled:false}}));
//     }
//   }
// }

/* ===== 날씨 이펙트 ===== */
const snowflakesContainer=document.querySelector('.snowflakes');
function generateSnowflake(){
  const s=document.createElement('div');
  s.style.animationDelay=(Math.random()*2)+'s';
  s.style.animationDuration=(Math.random()*5+5)+'s';
  s.style.left=Math.floor(Math.random()*101)+'%';
  s.style.position='absolute';s.style.top='-10px';s.style.width='10px';s.style.height='10px';s.style.backgroundColor='rgba(255,255,255,.8)';s.style.borderRadius='50%';
  snowflakesContainer.appendChild(s);
  setTimeout(()=>snowflakesContainer.removeChild(s),7000);
}
setInterval(generateSnowflake,200);

/* ===== Haptics (모바일) ===== */
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
function canVibrate() { return isMobile && typeof navigator.vibrate === "function" && document.visibilityState === "visible"; }
function vibrate(pattern) { if (!canVibrate()) return false; return navigator.vibrate(pattern) !== false; }
function hapticForNotch(delta) { if (delta !== 0) vibrate([80, 10, 80]); }
function hapticForEB() { vibrate([80, 100, 80]); }

/* ===== 차량 JSON 로드 (캐시 무시) ===== */
let vehicle=null; let brakeDecels={};
const cacheBust=()=>`?v=${Date.now()}`;
fetch('./e233_1000.json'+cacheBust(),{cache:'no-store'})
  .then(r=>r.json()).then(data=>{
    vehicle=data; document.getElementById('carName').textContent=vehicle.name;
    if(vehicle.notch_accels && vehicle.notches){
      brakeDecels={}; for(let i=0;i<vehicle.notches;i++){ brakeDecels[i]=Math.abs(vehicle.notch_accels[vehicle.notches-1-i]??0); }
    }
  }).catch(console.error);

/* ===== DOM ===== */
const remEl=document.getElementById("rem"),
      spdEl=document.getElementById("spd"),
      notchEl=document.getElementById("notch"),
      fb=document.getElementById("fb"),
      timerEl=document.getElementById("timer");
const overlay=document.getElementById("overlay"),
      btnStart=document.getElementById("btnStart"),
      canvas=document.getElementById("hud"),
      ctx=canvas.getContext("2d");
const weatherSelect=document.getElementById("weatherSelect"),
      snowflakes=document.querySelector(".snowflakes"),
      raindrops=document.querySelector(".raindrops");

function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; } 
addEventListener("resize",resize); resize();

function getEbIdx(){
  const acc = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const n   = acc ? acc.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  return Math.max(1, n - 1); // 0:N, 1..EB-1:B..., EB:마지막
}
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}

/* ===== 편성 & 탑승률 ===== */
function updateTrainLength(){ const L=document.getElementById("trainLength").value; ws.send(JSON.stringify({type:"cmd",payload:{name:"setTrainLength",length:L}})); sendLoadRate(); }
function sendLoadRate(){
  const loadRate=parseFloat(document.getElementById("inputLoadRate").value)||0;
  const trainLength=parseInt(document.getElementById("trainLength").value)||8;
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: trainLength }}));
}

/* ===== 입력 보정 & 제한 ===== */
const inputSpeed=document.getElementById("inputSpeed"),
      inputDist=document.getElementById("inputDist"),
      inputGrade=document.getElementById("inputGrade"),
      inputLoadRate=document.getElementById("inputLoadRate");

const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function enforceInt(el,min,max){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^\d-]/g,'');}); el.addEventListener('change',()=>{let v=parseInt(el.value,10); if(isNaN(v)){el.value='';return;} el.value=String(clamp(v,min,max));});}
function enforceFloat(el,min,max,d=1){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^0-9.\-]/g,'');}); el.addEventListener('change',()=>{let v=parseFloat(el.value); if(isNaN(v)){el.value='';return;} v=clamp(v,min,max); el.value=v.toFixed(d);});}

/* ✅ 범위 갱신: 속도 40~130 / 거리 150~900 */
enforceInt(inputSpeed,40,130);
enforceInt(inputDist,150,900);
enforceInt(inputLoadRate,0,120);
enforceFloat(inputGrade,-10,10,1);

/* ✅ 속도별 최소 거리 규칙 */
function minDistForSpeed(v) {
  if (v >= 130) return 900;
  if (v >= 120) return 900;
  if (v >= 110) return 800;
  if (v >= 100) return 600;
  if (v >= 90)  return 500;
  if (v >= 80)  return 400;
  if (v >= 70)  return 300;
  if (v >= 60)  return 250;
  if (v >= 50)  return 200;
  return 150; // v >= 40
}
function showHint(msg) {
  fb.innerHTML = `<div class="warn">${msg}</div>`;
  setTimeout(() => {
    if (!st || !st.finished) fb.textContent = "Space로 시작. W/S로 브레이크 조절하세요.";
  }, 1200);
}
function applySpeedDistanceRule() {
  let v = Number(inputSpeed.value || 0);
  v = Math.min(130, Math.max(40, v));
  const requiredMin = minDistForSpeed(v);
  let d = Number(inputDist.value || 0);
  const absoluteMin = 150, absoluteMax = 900;
  const newMin = Math.max(absoluteMin, requiredMin);

  inputDist.min = String(newMin);

  if (isNaN(d) || d < newMin) {
    inputDist.value = String(newMin);
    showHint(`속도 ${v} km/h에서는 최소 거리 ${newMin} m 이상이어야 합니다.`);
  } else if (d > absoluteMax) {
    inputDist.value = String(absoluteMax);
  }
}
inputSpeed.addEventListener('change', applySpeedDistanceRule);
inputSpeed.addEventListener('input',  () => {
  const v = Number(inputSpeed.value || 0);
  const minD = minDistForSpeed(Math.min(130, Math.max(40, v)));
  inputDist.min = Math.max(150, minD);
});

/* ===== 날씨 UI ===== */
function muFromWeather(w){return w==="비옴"?0.6:(w==="눈옴"?0.3:1.0)}
function updateWeatherUI(){
  const w=weatherSelect.value, ov=document.getElementById("overlay");
  if(w==="눈옴"){snowflakes.style.display="block";raindrops.style.display="none";document.documentElement.style.background="#fff";document.body.style.background="#fff";ov.style.background="rgba(255,255,255,.15)";canvas.style.background="#fff";}
  else if(w==="비옴"){snowflakes.style.display="none";raindrops.style.display="block";document.documentElement.style.background="#4b5d67";document.body.style.background="#4b5d67";ov.style.background="rgba(40,60,80,.35)";canvas.style.background="#4b5d67";}
  else{snowflakes.style.display="none";raindrops.style.display="none";const g="radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";document.documentElement.style.background=g;document.body.style.background=g;ov.style.background="rgba(0,0,0,.6)";canvas.style.background="linear-gradient(#0b0f14,#0a1019)";}
}
weatherSelect.addEventListener("change",()=>{updateWeatherUI();const mu=muFromWeather(weatherSelect.value); if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:"cmd",payload:{name:"setMu",value:mu}}));}});
updateWeatherUI();

/* ===== 시작/재시작 ===== */
function startRun(){
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));

  applySpeedDistanceRule();

  const speed=Number(inputSpeed.value),
        dist=Number(inputDist.value),
        grade=Number(inputGrade.value),
        mu=muFromWeather(weatherSelect.value);

  if(ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"toggleTimer", enabled:true }}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"setInitial",speed,dist,grade,mu}}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"start"}}));
  }
  overlay.classList.add("hide"); isFinished=false; overlayShowingResult=false;
  btnMobileRestart.classList.add("hide");
}
btnStart.addEventListener("click", startRun);

/* 재시작 FAB */
const btnMobileRestart=document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", ()=>{
  if(!overlay.classList.contains("hide")) overlay.classList.add("hide");
  overlay.classList.remove("hide");
  overlayShowingResult=true;
  btnMobileRestart.classList.add("hide");
});

/* ===== 모바일 터치 조작 ===== */
if(/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)){
  const game=document.getElementById("hud");
  game.addEventListener("touchstart",(e)=>{
    if(!overlay.classList.contains("hide")) return;
    if(e.touches.length!==1) return;
    // forceManualOverride();
    const r=game.getBoundingClientRect(), y=e.touches[0].clientY-r.top, half=r.height/2;
    if(y<half){ hapticForNotch(+1); sendCmd("applyNotch",+1); }
    else      { hapticForNotch(-1); sendCmd("applyNotch",-1); }
  }, { passive: true });
}

/* ===== 키보드 ===== */
addEventListener("keydown", (e) => {
  if([" ","w","W","s","S","n","N","e","E","d","D", "a", "A"].includes(e.key)) e.preventDefault();
  if(e.repeat) return;

  if(e.key === " "){ 
    if(ws.readyState !== WebSocket.OPEN) return; 
    startRun(); 
  }
  else if(e.key === "w" || e.key === "W"){ 
    sendCmd("applyNotch", +1); 
  }
  else if(e.key === "s" || e.key === "S"){ 
    sendCmd("applyNotch", -1); 
  }
  else if(e.key === "n" || e.key === "N"){ 
    sendCmd("release", 0); 
  }
  else if(e.key === "e" || e.key === "E"){ 
    sendCmd("emergencyBrake", 0);  
  }
  else if(e.key === "d" || e.key === "D"){ 
    // 제동 1단
    sendCmd("setNotch", 1);  
  }
  else if(e.key === "a" || e.key === "A"){
    if(vehicle && vehicle.notches){
      sendCmd("setNotch", vehicle.notches - 2); // EB 직전 notch
    }
  }

});

/* ===== HUD & 상태 ===== */
const grade_percentEl=document.getElementById("grade_percent");
let isFinished=false, overlayShowingResult=false, st=null, lastTimestamp=0, prevMaxDistance=0;
function loop(ts){ if(!lastTimestamp) lastTimestamp=ts; lastTimestamp=ts; if(st) drawHUD(st); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// 헬퍼: 정수를 MM:SS 형식으로 바꾸기
function formatTimeSec(secInt) {
  const sign = secInt < 0 ? "+" : "";
  const s = Math.abs(secInt);
  const m = Math.floor(s / 60);
  const s2 = s % 60;
  return sign
    + (m < 10 ? "0" : "") + m + ": "   // 콜론 앞뒤에 공백 추가
    + (s2 < 10 ? "0" : "") + s2;
}

// ===== WebSocket (단일 핸들러로 교체) =====
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type !== "state") return;

  // 상태 저장
  st = msg.payload;
  window.st = st;

  // 숫자 HUD 갱신
  const remRaw = st.remaining_m;
  const rem = (typeof remRaw === "number") ? remRaw : parseFloat(remRaw);
  // 거리 표시
if (rem >= 0) {
  if (rem <= 2)  remEl.textContent = Math.round(rem * 100) + " cm";
  else           remEl.textContent = rem.toFixed(0) + " m";
} else {
  if (rem >= -2) remEl.textContent = "-" + Math.round(Math.abs(rem) * 100) + " cm";
  else           remEl.textContent = "-" + Math.abs(rem).toFixed(0) + " m";
}

// ✅ 색상 조건 적용 (±0.35m 이내면 초록색, 아니면 기본)
if (Math.abs(rem) <= 0.35) {
  remEl.style.color = "#9effb5";   // 초록
} else {
  remEl.style.color = "";          // 기본 (.stat의 하얀색으로 복귀)
}

  spdEl.textContent = (st.v * 3.6).toFixed(1);


  const maxIdx = (vehicle?.notches ?? 10) - 1; // EB 인덱스
let notchText = "N";
let notchColor = "";

if (st.lever_notch === 0) {
  notchText = "N";
  notchColor = "#9effb5";     // 초록
} else if (st.lever_notch === maxIdx) {
  notchText = "EB";
  notchColor = "#ff5757";     // 빨강
} else {
  notchText = `B${st.lever_notch}`;
  notchColor = "#ed9a09";     // 어두운 주황/황토색
}

notchEl.textContent = notchText;
notchEl.style.color = notchColor;




  grade_percentEl.textContent = (10 * st.grade_percent).toFixed(1);



  const running  = !!st.running;
  const finished = !!st.finished;
  const budget   = Number(st.time_budget_s ?? 0);
  const remainI  = Number(st.time_remaining_int ?? 0);
let toShowInt = (running || finished) ? remainI : Math.round(budget);
if (!Number.isFinite(toShowInt)) {
  const remainF = Number(st.time_remaining_s);
  toShowInt = Number.isFinite(remainF) ? Math.floor(remainF) : Math.floor(Number(st.t) || 0);
}

timerEl.textContent = formatTimeSec(toShowInt);

// ✅ 색상 조건 추가
if (Math.abs(toShowInt) <= 2) {
  timerEl.style.color = "#9effb5";   // 초록색
  timerEl.classList.remove('bad');
} else if (toShowInt < 0) {
  timerEl.style.color = "";          // 기본 색상 (CSS .stat)
  timerEl.classList.add('bad');      // 음수면 빨강
} else {
  timerEl.style.color = "";          // 기본 색상 (CSS .stat)
  timerEl.classList.remove('bad');
} 

  // 그래프/미니 인디케이터
  drawHUD(st);
  drawBrakeLadderMini(st);

  // ⚠ 피드백(fb) UI는 여기서 건드리지 마세요 (언어 토글은 setLang에서 처리)

// ✅ 재시작 FAB 표시/숨김
if (st.finished) {
  if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
    btnMobileRestart.classList.remove('hide');  // 모바일이면 표시
  } else {
    btnMobileRestart.classList.add('hide');     // PC에서는 숨김 유지
  }
} else {
  btnMobileRestart.classList.add('hide');       // 게임 진행 중에는 항상 숨김
}
};

/* ===== HUD 그리기 (기존 유지) ===== */
function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const v0=st.v, lever=st.lever_notch, currentPos=st.pos??0, stopPos=st.stopPos??500;
  const remaining=(typeof st.remaining_m==="number")?Math.max(0,st.remaining_m):Math.max(0,stopPos-currentPos);
  const maxDecel=Math.max(...Object.values(brakeDecels)); const maxStop=maxDecel>0?(v0*v0)/(2*maxDecel):0;
  const speedFactor=Math.max(.3,Math.min(1,v0/10)); const adjusted=remaining*(1+(1-speedFactor)*.5);
  const s_b1=(brakeDecels[1]??0)>0?(v0*v0)/(2*brakeDecels[1]):0, s_b2=(brakeDecels[2]??0)>0?(v0*v0)/(2*brakeDecels[2]):0;
  const target=Math.max(1,maxStop*1.5,Math.max(1,Math.sqrt(adjusted)*10)*1.2,s_b1*1.1,s_b2*1.1);
  prevMaxDistance = prevMaxDistance===0 ? target : prevMaxDistance*.9 + target*.1;

  const left=48*dpr, right=12*dpr, usableW=w-left-right, X=d=>left+usableW*(d/prevMaxDistance);
  const vmax=Math.max(1,v0*3.6*1.2);
  const bottom=28*dpr, top=12*dpr, usableH=h-bottom-top, Y=v=>h-bottom-usableH*(v/vmax);

  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,h-bottom); ctx.lineTo(w-right,h-bottom); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let d=0; d<=prevMaxDistance; d+=100){ const x=X(d); ctx.beginPath(); ctx.moveTo(x,h-bottom); ctx.lineTo(x,h-bottom+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(d)}`,x,h-bottom+6*dpr); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let k=0;k<=vmax;k+=10){ const y=Y(k); ctx.beginPath(); ctx.moveTo(left-4*dpr,y); ctx.lineTo(left,y); ctx.stroke(); ctx.fillText(`${k}`,left-6*dpr,y); }

  ctx.lineWidth=2*dpr; 
  const maxNotch = vehicle?.notches ?? 10;   // 총 개수(0~maxIdx)
  const maxIdx   = maxNotch - 1;  // EB 인덱스
  for(let n=0;n<maxNotch;n++){
    const a=brakeDecels[n]??0; if(a<=0) continue;
    const s=(v0*v0)/(2*a);
    ctx.beginPath(); ctx.strokeStyle = n===lever ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<=100;i++){
      const f=i/100, ds=s*f, v=Math.sqrt(Math.max(0,v0*v0-2*a*ds));
      const x=X(ds), y=Y(v*3.6); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle=n===lever?"#ffae00":"#3fa9ff"; ctx.font=`${12*dpr}px 'Orbitron', sans-serif`;
    const tX=X(s); const label = (n===0) ? "N" : (n===maxIdx ? "EB" : `B${n}`);
    ctx.fillText(label, tX+5*dpr, Y(0)+12*dpr);
  }

  const xRed=X(remaining); ctx.strokeStyle="#f00"; ctx.lineWidth=1.5*dpr; ctx.beginPath(); ctx.moveTo(xRed,Y(0)); ctx.lineTo(xRed,Y(vmax)); ctx.stroke();
  ctx.fillStyle="#f00"; ctx.font=`${14*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center"; ctx.fillText("남은 거리", xRed, Y(vmax)-18*dpr);

  // const ribbonW=16*dpr, ribbonH=h*.9, ribbonX=w-right-ribbonW-10*dpr+20, ribbonY=((h-ribbonH)/2)-32;
  // ctx.fillStyle="rgba(100,100,100,.1)"; ctx.strokeStyle="rgba(100,100,100,.3)"; ctx.lineWidth=1.5*dpr;
  // ctx.beginPath(); ctx.rect(ribbonX,ribbonY,ribbonW,ribbonH); ctx.fill(); ctx.stroke();

  // const centerY=(ribbonY+ribbonH/2)-14, barH=12*dpr;
  // ctx.fillStyle="rgba(60,60,60,.9)"; ctx.fillRect(ribbonX+2*dpr, centerY-barH/2, ribbonW-4*dpr, barH);

  // PC/모바일 판별
  const isMobile = window.innerWidth < 768; 

  // 보정값 설정 (원하는 값으로 수정 가능)
  // -32 -14
  const offsetRibbonY = isMobile ? -32 : -12; 
  const offsetCenterY = isMobile ? -14 : -5; 

  // 리본 위치/크기 계산
  const ribbonW = 16 * dpr, 
        ribbonH = h * .9, 
        ribbonX = w - right - ribbonW - 10 * dpr + 20, 
        ribbonY = ((h - ribbonH) / 2) + offsetRibbonY;

  ctx.fillStyle = "rgba(100,100,100,.1)";
  ctx.strokeStyle = "rgba(100,100,100,.3)";
  ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath();
  ctx.rect(ribbonX, ribbonY, ribbonW, ribbonH);
  ctx.fill();
  ctx.stroke();

  // 중앙 바
  const centerY = (ribbonY + ribbonH / 2) + offsetCenterY, 
        barH = 12 * dpr;

  ctx.fillStyle = "rgba(60,60,60,.9)";
  ctx.fillRect(ribbonX + 2 * dpr, centerY - barH / 2, ribbonW - 4 * dpr, barH);

  const rem=Math.min(Math.max(st.remaining_m??st.L,-st.L), st.L);
  const diamondW=16*dpr, diamondH=10*dpr, dX=ribbonX+ribbonW/2;
  const normalized=(rem-(-7))/(7-(-7));
  const dY=ribbonY+(ribbonH*(1-normalized))-diamondH/2;
  const adjY=Math.min(Math.max(dY, ribbonY-10*dpr), ribbonY+ribbonH-diamondH+10*dpr);
  ctx.fillStyle="#444"; ctx.strokeStyle="#222"; ctx.lineWidth=2*dpr; ctx.beginPath();
  ctx.moveTo(dX, adjY-diamondH/2); ctx.lineTo(dX+diamondW/2, adjY); ctx.lineTo(dX, adjY+diamondH/2); ctx.lineTo(dX-diamondW/2, adjY);
  ctx.closePath(); ctx.fill(); ctx.stroke();

/* === TASC 경고등 (HUD 위) === */
/* === TASC 경고등 (HUD 위) === */
/* === TASC 경고등 (HUD 위) === */
{
  const pad = 8 * dpr;       // 텍스트와 테두리 사이 여백
  const textW = 18 * dpr;    
  const textH = 9 * dpr;     
  const radius = 2 * dpr;    // 모서리 반경

  const lightW = textW + pad*2 + 8*dpr; // 기존보다 6px 더 늘림
  const lightH = textH + pad*2 - 2*dpr; // 기존보다 2px 줄임

  const isMobile = window.innerWidth < 768;
  const lightX = isMobile 
    ? w - lightW - 35 * dpr
    : w - lightW - 30 * dpr;
  const lightY = 15 * dpr;

  const blinkOn = Math.floor(Date.now() / 250) % 2 === 0;

  // Set the fill color based on the state
  let fillColor = "#444"; 
  if (!st.tasc_armed && !st.tasc_enabled) fillColor = "#444";
  else if (st.tasc_active) fillColor = "#fec670";
  else if (st.tasc_armed && !st.tasc_active && blinkOn) fillColor = "#fec670";

  // Draw rounded rectangle for TASC light
  ctx.beginPath();
  ctx.moveTo(lightX + radius, lightY);
  ctx.lineTo(lightX + lightW - radius, lightY);
  ctx.quadraticCurveTo(lightX + lightW, lightY, lightX + lightW, lightY + radius);
  ctx.lineTo(lightX + lightW, lightY + lightH - radius);
  ctx.quadraticCurveTo(lightX + lightW, lightY + lightH, lightX + lightW - radius, lightY + lightH);
  ctx.lineTo(lightX + radius, lightY + lightH);
  ctx.quadraticCurveTo(lightX, lightY + lightH, lightX, lightY + lightH - radius);
  ctx.lineTo(lightX, lightY + radius);
  ctx.quadraticCurveTo(lightX, lightY, lightX + radius, lightY);
  ctx.closePath();

  // Fill the rectangle with the color
  ctx.fillStyle = fillColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const gradient = ctx.createLinearGradient(lightX, lightY, lightX, lightY + lightH);
  gradient.addColorStop(0, "#999");  // Lighter gray at the top
  gradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // Set text style and alignment for TASC text
  let tascTextColor = "#fff"; // 기본 텍스트 색상 (흰색)

  // 불이 들어왔을 때 자동 버튼처럼 검은색으로 바꾸기
  if (st.tasc_enabled && st.tasc_active) {
    tascTextColor = "#000";  // 불이 들어오면 텍스트 색상 검은색
  }

  ctx.fillStyle = tascTextColor; // 텍스트 색상 변경
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Split text by newline and position each line
  const text = "TASC\n자동";
  const lines = text.split("\n");
  const lineHeight = 10 * dpr; // Adjust this value for spacing between lines

  // Draw each line at the center position
  lines.forEach((line, index) => {
    ctx.fillText(line, lightX + lightW / 2, lightY + lightH / 2 + index * lineHeight);
  });

  /* === 정위치 정차 버튼 (초록색) === */
  const stopBtnX = lightX - lightW - 3 * dpr;  // 정위치 정차 버튼의 X 위치
  const stopBtnY = lightY;  // Y 위치는 TASC 경고등과 동일하게

  const stopBtnW = textW + pad * 2 + 8 * dpr; // 정위치 정차 버튼의 너비
  const stopBtnH = textH + pad * 2 - 2 * dpr; // 정위치 정차 버튼의 높이

  let stopBtnColor = "#444"; // 기본 회색
  let stopTextColor = "#fff"; // 기본 텍스트 색상 (흰색)

  // Check if the button should be green (정위치 정차 완료 상태)
  if (st.tasc_enabled && st.v == 0) {
    stopBtnColor = "#9be071";  // 초록색 (정위치 정차 완료 상태)
    stopTextColor = "#000";  // 초록색일 때 텍스트 색상 검은색
  }

  // Draw rounded rectangle for Stop Button
  ctx.beginPath();
  ctx.moveTo(stopBtnX + radius, stopBtnY);
  ctx.lineTo(stopBtnX + stopBtnW - radius, stopBtnY);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY, stopBtnX + stopBtnW, stopBtnY + radius);
  ctx.lineTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH - radius);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH, stopBtnX + stopBtnW - radius, stopBtnY + stopBtnH);
  ctx.lineTo(stopBtnX + radius, stopBtnY + stopBtnH);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY + stopBtnH, stopBtnX, stopBtnY + stopBtnH - radius);
  ctx.lineTo(stopBtnX, stopBtnY + radius);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY, stopBtnX + radius, stopBtnY);
  ctx.closePath();

  // Fill the button with the color
  ctx.fillStyle = stopBtnColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const stopBtnGradient = ctx.createLinearGradient(stopBtnX, stopBtnY, stopBtnX, stopBtnY + stopBtnH);
  stopBtnGradient.addColorStop(0, "#999");  // Lighter gray at the top
  stopBtnGradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = stopBtnGradient;
  ctx.stroke();

  // Set text style and alignment for Stop Button text
  ctx.fillStyle = stopTextColor;  // 텍스트 색상은 정위치 상태에 따라 결정
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Draw text for the Stop Button
  const stopText = "TASC\n정위치";
  const stopLines = stopText.split("\n");
  const stopLineHeight = 10 * dpr;  // Adjust this value for spacing between lines

  // Draw each line of text at the center position
  stopLines.forEach((line, index) => {
    ctx.fillText(line, stopBtnX + stopBtnW / 2, stopBtnY + stopBtnH / 2 + index * stopLineHeight);
  });
}


}


/* ===== 브레이크 미니 인디케이터 ===== */
const ladderCanvas = document.getElementById('brakeLadder');
function sizeLadderCanvas() {
  if (!ladderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ladderCanvas.clientWidth;
  const cssH = ladderCanvas.clientHeight;
  ladderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  ladderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeLadderCanvas);
sizeLadderCanvas();

function drawBrakeLadderMini(st) {
  const ctx2 = ladderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ladderCanvas.width, h = ladderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

  const accArr  = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const notches = accArr ? accArr.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  const ebIdx   = accArr ? Math.max(1, accArr.length - 1) : Math.max(1, notches - 1);
  const blocks  = ebIdx;
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0));

  ctx2.fillStyle = "rgba(100,100,100,0.10)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = 2 * dpr;
  const gap  = Math.max(2 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;
    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);
    if (cur !== ebIdx && k <= cur) { ctx2.fillStyle = "#ffd34d"; ctx2.fillRect(x, y, bW, bH); }
    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) { ctx2.fillStyle = "#ff5757"; ctx2.fillRect(x, yEB, bW, bH); }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);

  
}

/* ===== 전동차/시리즈/편성 ===== */
const TRAIN_DB={
  E233:[
    {code:"JR EAST E233-1000", lines:"게이힌토호쿠·네기시", file:"./e233_1000.json", lengths:[10]},
    {code:"JR EAST E233-2000", lines:"조반 각역·쾌속", file:"./e233_2000.json", lengths:[10]},
    {code:"JR EAST E233-3000", lines:"도카이도·도호쿠·타카사키·우에노도쿄/소부쾌속·조반 직통", file:"./e233_3000.json", lengths:[5,10,15]}
  ],
  E235:[
    {code:"JR EAST E235-0", lines:"야마노테", file:"./e235_0.json", lengths:[11]},
    {code:"JR EAST E235-1000", lines:"요코스카·소부쾌속", file:"./e235_1000.json", lengths:[4,11,15]}
  ],
  JRW223: [
    { code: "JR WEST 223-0",
      lines: "오사카 순환선 · 한와선 · 간사이공항선 직결 · 기노쿠니선",
      file: "./223_0000.json", lengths: [4] },
    { code: "JR WEST 223-1000",
      lines: "비와코·JR 교토·JR 고베 라인 등",
      file: "./223_1000.json", lengths: [4,8] }
  ],
  JRW225: [
    { code: "JR WEST 225-0",
      lines: "비와코·JR 교토·JR 고베 라인 등",
      file: "./225_0000.json", lengths: [4,8] },
    { code: "JR WEST 225-5000",
      lines: "오사카 순환선 · 한와선 · 간사이공항선",
      file: "./225_5000.json", lengths: [4] },
    { code: "JR WEST 225-6000",
      lines: "JR 고베선 · 후쿠치야마선",
      file: "./225_6000.json", lengths: [4,6] }
  ],
  JRW323: [{ code: "JR WEST 323-0", lines: "오사카 순환선 전용", file: "./323_0000.json", lengths: [8] }],
  JRW285: [{ code: "JR WEST 285-0/3000", lines: "일반 침대특급 선라이즈 이즈모·세토", file: "./285.json", lengths: [7, 14] }],
  JRH261: [{ code: "JR HOKKAIDO KiHa 261-5000", lines: "북해도의 혹한에 최적화된 특급 디젤동차", file: "./261_5000.json", lengths: [4, 5, 6, 10] }],
JR103: [{
  code: "JR/JNR 103-0",
  lines: "1960~80년대 일본 통근형 전동차의 상징",
  file: "./103.json",
  lengths: [4, 6, 8, 10, 15]
}],
EF510: [{
  code: "JR EAST Cassiopeia • 초호화 침대특급",
  lines: "우에노↔아오모리",
  file: "./e26.json",
  lengths: [13]
}],
K3000: [{
  code: "Keisei 3000",
  lines: "케이세이 본선, 나리타 공항선",
  file: "./keisei3000.json",
  lengths: [6, 8]
}],
T5300: [{
  code: "Toei 5300",
  lines: "도에이 아사쿠사선, 케이세이 본선, 게이큐 본선",
  file: "./toei5300.json",
  lengths: [8]
}]


};

const trainFamilyEl=document.getElementById('trainFamily');
const trainSeriesEl=document.getElementById('trainSeries');
const trainLengthEl=document.getElementById('trainLength');

function setTrainLengthOptions(lengths){
  trainLengthEl.innerHTML="";
  lengths.forEach(len=>{
    const opt=document.createElement('option');
    opt.value=String(len); opt.textContent=`${len}량`;
    trainLengthEl.appendChild(opt);
  });
  updateTrainLength();
}
function loadVehicleFile(filePath){
  fetch(filePath + cacheBust(), { cache: 'no-store' })
    .then(res => res.json())
    .then(data => {
      vehicle = data;
      vehicle.notches = (vehicle.notch_accels || []).length;
      document.getElementById('carName').textContent = vehicle.name;

      brakeDecels = {};
      if (vehicle.notch_accels && vehicle.notches) {
        for (let i = 0; i < vehicle.notches; i++) {
          brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
        }
      }

      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setVehicleFile", file: filePath } }));
      }
      sendLoadRate();
    })
    .catch(console.error);
}
function populateSeries(){
  const fam=trainFamilyEl.value, list=TRAIN_DB[fam]||[];
  trainSeriesEl.innerHTML="";
  list.forEach((s,i)=>{
    const opt=document.createElement('option');
    opt.value=s.file; opt.dataset.lengths=JSON.stringify(s.lengths);
    opt.textContent=`${s.code} (${s.lines})`;
    if(i===0) opt.selected=true;
    trainSeriesEl.appendChild(opt);
  });
  if(list[0]){ setTrainLengthOptions(list[0].lengths); loadVehicleFile(list[0].file); }
}
trainFamilyEl.addEventListener('change', populateSeries);
trainSeriesEl.addEventListener('change',(e)=>{
  const opt=e.target.selectedOptions[0];
  const lengths=JSON.parse(opt.dataset.lengths||"[]");
  setTrainLengthOptions(lengths);
  loadVehicleFile(opt.value);
});
populateSeries(); // 최초 세팅
</script>

<!-- ===== 10s 언어 토글 (ko <-> en), 피드백 포함 ===== -->
<script>


// ===== 언어 토글 =====
(function(){
  const dict = {
    ko: {
      htmlLang: "ko",
      docTitle: "TASC Simulator",
      labelRemainTime: "남은시간",
      labelSpeed: "속도",
      labelRemainDist: "정차",
      labelGrade: "구배",
      labelNotch: "제동",
      labelStartKey: "시작",
      labelUp: "강화",
      labelDown: "완화",
      labelRelease: "해방",
      subtitleIntro: 
  "B1/B2단으로 제동을 시작해 남은거리 <b>150m</b> (P3 TASC 지상자) 지점까지 속도를 <b>60km/h</b> 이하로 낮추세요. 그 이후에는 <b>TASC(자동정차)</b>가 자동으로 제동을 이어받습니다.",

      labelTASC: "TASC",
      labelTrain: "전동차",
      labelSeries: "시리즈",
      labelInitSpeed: "초기 속도 (km/h)",
      labelInitDist: "거리 (m)",
      labelGradeInput: "경사도 (‰)",
      labelWeather: "날씨",
      labelLoadRate: "승객 탑승률 (%)",
      labelTrainLength: "편성",
      btnStart: "Start (Space)",
      btnMobileRestart: "재시작",
      feedback: {
        early_good: "초기 제동을 수행함 — 승차감 양호",
        early_bad: "초기 제동을 게을리함 — 승차감 불쾌",
        stop_good: "정차 시 B1로 정차함 — 승차감 양호",
        stop_bad: "정차 시 B1로 정차하지 않음 — 승차감 불쾌",
        step_good: "기본제동 (계단제동/완해) 수행함",
        step_bad: "기본제동 (계단제동/완해) 미흡 — 승객 쏠림",
        eb_good: "영업 안전 제동범위 준수",
        eb_bad: "불필요한 비상제동(EB) 사용 — 급감속 충격",
        score: n=>`최종 점수: ${n}점`,
        stopErr: m=>`정지 오차: ${m.toFixed(2)} m`,
         hintIdle: () => {
          const tips = [
            "팁: B1/B2로 속도를 60 km/h 이하로 낮춘 뒤 해방(N단)하지 말고 마스콘을 그대로 유지하세요.",
            "팁: TASC 정차 표시등이 켜지면 TASC가 자동 제동을 시작했음을 의미합니다.",
            "팁: TASC 정차 표시등이 깜빡이면, TASC 개입 전에 수동 조작이 가능하다는 뜻입니다.",
            "팁: 열차가 정위치에 도달하면 TASC 정위치 표시등이 켜집니다.",
            "팁: 남은 거리를 확인하며 여유 있게 B1으로 정차하여 승차감을 확보하세요.",
            "팁: A키는 최대 상용 제동, D키는 B1 제동, E키는 비상제동을 발동시킵니다.",
            "팁: 정차 직전 마스콘을 풀었다 다시 조작하는 일명 \"톱질\" 행위는 승차감을 크게 저하시킵니다.",
          ];

          return tips[Math.floor(Math.random() * tips.length)];
        },
        hintAgain: "Space로 다시 시작 · N 해방 · W/S로 조작"
      }
    },
    en: {
      htmlLang: "en",
      docTitle: "TASC Simulator",
      labelRemainTime: "STA",
      labelSpeed: "Speed",
      labelRemainDist: "Distance",
      labelGrade: "Grade",
      labelNotch: "Brake",
      labelStartKey: "Start",
      labelUp: "B+",
      labelDown: "B-",
      labelRelease: "Release",
      subtitleIntro: 
  "Begin braking with B1/B2 and reduce speed to below <b>60km/h</b> by <b>150m</b> remaining (P3 TASC beacon). After that, <b>TASC (Autopilot)</b> takes over brake control.",


      labelTASC: "TASC",
      labelTrain: "Train",
      labelSeries: "Series",
      labelInitSpeed: "Initial Speed (km/h)",
      labelInitDist: "Distance (m)",
      labelGradeInput: "Grade (‰)",
      labelWeather: "Weather",
      labelLoadRate: "Passenger Load (%)",
      labelTrainLength: "Formation",
      btnStart: "Start (Space)",
      btnMobileRestart: "Restart",
      feedback: {
  early_good: "You braked early — the ride was smooth.",
  early_bad: "You braked late — the ride felt rough.",
  stop_good: "Stopped at B1 — the ride was smooth.",
  stop_bad: "Failed to stop at B1 — the ride felt rough.",
  step_good: "Stepwise braking was applied correctly",
  step_bad: "Stepwise braking was poor, causing jolts and discomfort for passengers",
  eb_good: "Safe braking range observed — no EB applied",
  eb_bad: "Unnecessary EB applied, causing a harsh jolt",
  score: n => `Final score: ${n}`,
  stopErr: m => `Stopping error: ${m.toFixed(2)} m`,
  hintIdle: () => {
    const tips = [
      "Tip: Reduce speed below 60 km/h with B1/B2 and keep the master controller in place (do not release with N).",
      "Tip: If the TASC stop indicator lights up, it means TASC has started automatic braking.",
      "Tip: If the TASC stop indicator flashes, you can manually intervene before TASC takes over.",
      "Tip: When the train reaches the exact stop position, the TASC stop-position indicator will light up.",
      "Tip: Press A for maximum service brake, D for B1 brake, and E for emergency brake.",
      "Tip: Check the remaining distance and stop gently with B1 to ensure a smooth ride.",
      "Tip: Reapplying and releasing the master controller just before stopping can severely affect ride comfort."

    ];

    return tips[Math.floor(Math.random() * tips.length)];
  },

  hintAgain: "Press Space to restart, N to release, W/S to brake."
}
    }
  };

  const nodes = {
    labelRemainTime: document.getElementById("labelRemainTime"),
    labelSpeed: document.getElementById("labelSpeed"),
    labelRemainDist: document.getElementById("labelRemainDist"),
    labelGrade: document.getElementById("labelGrade"),
    labelNotch: document.getElementById("labelNotch"),
    subtitleIntro: document.getElementById("subtitleIntro"),
    labelTASC: document.getElementById("labelTASC"),
    labelTrain: document.getElementById("labelTrain"),
    labelSeries: document.getElementById("labelSeries"),
    labelInitSpeed: document.getElementById("labelInitSpeed"),
    labelInitDist: document.getElementById("labelInitDist"),
    labelGradeInput: document.getElementById("labelGradeInput"),
    labelWeather: document.getElementById("labelWeather"),
    labelLoadRate: document.getElementById("labelLoadRate"),
    labelTrainLength: document.getElementById("labelTrainLength"),
    btnStart: document.getElementById("btnStart"),
    btnMobileRestart: document.getElementById("btnMobileRestart"),
    fb: document.getElementById("fb")
  };

  function setLang(lang){
    const d = dict[lang];
    document.documentElement.lang = d.htmlLang;
    document.title = d.docTitle;

    [
      "labelRemainTime","labelSpeed","labelRemainDist","labelGrade","labelNotch",
      "labelStartKey","labelUp","labelDown","labelRelease",
      "labelTASC","labelTrain","labelSeries","labelInitSpeed","labelInitDist",
      "labelGradeInput","labelWeather","labelLoadRate","labelTrainLength"
    ].forEach(k => { if(nodes[k]) nodes[k].innerText = d[k]; });

    if(nodes.subtitleIntro) nodes.subtitleIntro.innerHTML = d.subtitleIntro;
    if(nodes.btnStart) nodes.btnStart.textContent = d.btnStart;
    if(nodes.btnMobileRestart) nodes.btnMobileRestart.textContent = d.btnMobileRestart;

    // ---- 피드백 번역 ----
    if (nodes.fb) {
      const fbd = d.feedback;
      const st = window.st;
      if (st && st.finished) {
        const issues = st.issues ?? {};
        let rows = [];
        rows.push({ bad: !!issues.early_brake_too_short, goodText: fbd.early_good, badText: fbd.early_bad });
        rows.push({ bad: !!issues.stop_not_b1,           goodText: fbd.stop_good,  badText: fbd.stop_bad  });
        rows.push({ bad: !!issues.step_brake_incomplete, goodText: fbd.step_good,  badText: fbd.step_bad  });
        rows.push({ bad: !!issues.unnecessary_eb_usage,  goodText: fbd.eb_good,    badText: fbd.eb_bad    });

        let html = rows.map(r =>
          `<div class="${r.bad ? "bad" : "ok"}">${r.bad ? r.badText : r.goodText}</div>`
        ).join("");

        const stopErr = Number(st.stop_error_m ?? 0);
        const score   = Number(st.score ?? 0);
        const goodErr = Math.abs(stopErr) <= 2;

        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.stopErr(stopErr)}</div>`;
        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.score(score)}</div>`;
        html += `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">${fbd.hintAgain}</div>`;
        nodes.fb.innerHTML = html;
      } else {
        nodes.fb.textContent = fbd.hintIdle();
      }
    }
  }

  // ===== 5초마다 토글 =====
  let current = "ko";
  setLang(current);
  setInterval(()=>{
    current = (current==="ko") ? "en" : "ko";
    setLang(current);
  }, 7000);
})();

</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  ©2025 Hyungsuk Choi, University of Maryland
</footer>
</body>
</html>