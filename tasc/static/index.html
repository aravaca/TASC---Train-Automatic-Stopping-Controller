<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
<style>
html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}

.game-background,.snow-background,.rain-background{ background: transparent !important; }

#wrap { max-width: 960px; margin: 18px auto; padding: 0 12px; }
.row { display: flex; gap: 12px; align-items: center; }

.card {
  background: rgba(18,24,38,0.7);
  border: 1px solid rgba(0,246,255,0.15);
  border-radius: 16px;
  padding: 16px;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  transition: transform .2s, box-shadow .2s;
}
.card:hover { transform: translateY(-2px); box-shadow: 0 12px 28px rgba(0,0,0,0.7); }

canvas { width: 100%; height: 320px; background: linear-gradient(#0b0f14,#0a1019); border-radius: 12px; }

.kbd { background: rgba(10,18,28,0.8); border:1px solid #2b3f5f; color:#9fc5ff; padding:2px 6px; border-radius:6px; font-size:12px; }
.stat { font-size: 32px; font-weight: 800; color:#fff; text-shadow:0 0 4px rgba(0,200,255,0.8); }

.ok { color:#9effb5; } .warn{ color:#ffd18f; } .bad{ color:#ff9b9b; }

button,.btn-primary{
  background: linear-gradient(135deg,#00c6ff,#0072ff); color:#fff; border:none; border-radius:12px;
  padding:10px 16px; font-size:15px; font-weight:600; transition: background .3s, transform .1s;
}
button:hover,.btn-primary:hover{ background: linear-gradient(135deg,#0072ff,#00c6ff); transform: translateY(-1px); }

#overlay{
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); z-index: 9999;
}
#overlay.hide{ display:none; }

.title{ font-size:1.4rem; font-weight:600; margin-bottom:4px; color:#00f6ff; }
.subtitle{ font-size:.9rem; color:#9fc5ff; margin-bottom:16px; }

.form-label{ display:block; font-size:.85rem; margin-bottom:12px; text-align:left; font-weight:500; color:#cceaff; }
.form-input{
  width:100%; box-sizing:border-box; padding:8px 10px; font-size:.9rem;
  border:1px solid rgba(0,246,255,0.3); border-radius:8px; margin-top:4px; background: rgba(10,18,28,0.6); color:#e7f0ff;
}
.form-input:focus{ border-color:#00f6ff; outline: none; }

.kbd-info{ margin:16px 0; font-size:.85rem; color:#9fc5ff; }

@keyframes neonGlow{
  0%,100%{ text-shadow:0 0 5px #fff,0 0 10px #fff,0 0 20px currentColor,0 0 30px currentColor,0 0 40px currentColor,0 0 55px currentColor,0 0 75px currentColor; opacity:1; }
  50%{ text-shadow:0 0 2px #fff,0 0 5px #fff,0 0 10px currentColor,0 0 15px currentColor,0 0 20px currentColor,0 0 30px currentColor,0 0 40px currentColor; opacity:.8; }
}
.grade-S,.grade-A{ animation: neonGlow 2s ease-in-out infinite; }
.grade-S{ color:gold; } .grade-A{ color:#4CAF50; }

/* 눈/비 */
.snowflakes,.raindrops{
  position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none; overflow:hidden;
}
.snowflakes{ z-index: 9999; }
.raindrops{ z-index: 9998; }
.snowflakes div{ position:absolute; background:#fff; width:10px; height:10px; border-radius:50%; opacity:.8; animation: snow 5s linear infinite; }
@keyframes snow{ 0%{ transform: translateY(-20px);} 100%{ transform: translateY(100vh);} }
.raindrops div{ position:absolute; background-color: rgba(173,216,230,0.8); width:2px; height:15px; animation: rain .5s linear infinite; }
@keyframes rain{ 0%{ transform: translateY(-20px);} 100%{ transform: translateY(100vh);} }

body{ overflow-x:hidden; overflow-y:auto; }
@media (max-width:768px){
  html,body{ height:100%; } body{ -webkit-overflow-scrolling:touch; }
  #wrap{ padding-bottom:96px; } canvas#hud{ height:42vh; }
}
.fab{ position:fixed; left:50%; bottom:24px; transform:translateX(-50%); padding:12px 18px; font-weight:700; border-radius:999px; background:linear-gradient(135deg,#00c6ff,#0072ff); color:#fff; border:none; z-index:10000; box-shadow:0 8px 24px rgba(0,0,0,.35); }
.fab.hide{ display:none; }
.fab:hover{ background:linear-gradient(135deg,#0072ff,#00c6ff); transform:translateX(-50%) translateY(-1px); }

.mobile-control-guide{ display:none; font-size:14px; color:#9fc5ff; background:rgba(18,24,38,0.7); border:1px solid rgba(0,246,255,0.2); padding:8px 12px; border-radius:8px; margin-bottom:12px; }
@media (max-width:768px){ .mobile-control-guide{ display:block; } }

.tasc-toggle{ position:absolute; top:12px; right:16px; display:flex; align-items:center; gap:6px; font-family:'Orbitron', sans-serif; z-index:1001; }
.tasc-toggle .tasc-label{ font-size:12px; font-weight:600; color:#9fc5ff; user-select:none; }
.tasc-toggle input{ display:none; }
.tasc-toggle .slider{
  position:relative; display:inline-block; width:46px; height:24px; background:rgba(255,255,255,0.25); border-radius:24px; cursor:pointer; transition: background-color .3s; box-shadow: inset 0 0 4px rgba(0,0,0,0.3);
}
.tasc-toggle .slider::before{
  content:""; position:absolute; height:18px; width:18px; left:3px; bottom:3px; background:#fff; border-radius:50%; transition: transform .3s; box-shadow:0 1px 3px rgba(0,0,0,.4);
}
.tasc-toggle input:checked + .slider{ background: linear-gradient(135deg,#00c6ff,#0072ff); }
.tasc-toggle input:checked + .slider::before{ transform: translateX(22px); }
</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

    <div class="mobile-control-guide">
      📱 <b>모바일 조작 안내:</b> 캔버스(그래프) 위를 터치하세요.<br>
      위쪽 터치 → 브레이크 강화 🔼<br>
      아래쪽 터치 → 브레이크 완화 🔽<br>
      정차 후 아래 화면에서 피드백을 확인하세요.
    </div>

    <div class="card" style="flex:1 1 260px">
      <div id="carName" style="font-size:20px" class="stat">차량 로딩 중...</div>
      <div>남은 거리 <span class="stat" id="rem">—</span> m</div>
      <div>속도 <span class="stat" id="spd">—</span> km/h</div>
      <div>노치 <span class="stat" id="notch">0.0</span></div>
      <div>구배 <span class="stat" id="grade_percent">—</span> %</div>
      <div>경과시간 <span class="stat" id="timer">0.000</span> s</div>
      <div style="margin-top:8px">조작: <span class="kbd">Space</span> 시작 · <span class="kbd">W</span> 브레이크 강화(노치↑) · <span class="kbd">S</span> 완화(노치↓) · <span class="kbd">N</span> 해방</div>
    </div>

    <div class="card" style="flex:2 1 520px">
      <canvas id="hud"></canvas>
    </div>

    <div class="card" style="flex:1 1 240px">
      <div><b>피드백</b></div>
      <div id="fb">Space를 눌러 시작하세요.</div>
    </div>
  </div>
</div>

<!-- Overlay -->
<div id="overlay">
  <div class="card">
    <!-- TASC ON/OFF 토글 -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label">TASC</span>
    </div>

    <h2 class="title">🚉 TASC 기반 정차 트레이너</h2>
    <p class="subtitle">초기값 입력 → 상단 <b>TASC</b> 설정 → <b>Space</b> 또는 아래 버튼.</p>

    <!-- 새로 추가: 열차군/시리즈 선택 -->
    <label class="form-label">
      전동차
      <select id="trainFamily" class="form-input">
        <option value="E233" selected>E233</option>
        <option value="E235">E235</option>
      </select>
    </label>

    <label class="form-label">
      시리즈
      <select id="trainSeries" class="form-input">
        <!-- JS에서 열차군에 따라 동적으로 채움 -->
      </select>
    </label>

    <label class="form-label">
      초기 속도 (km/h)
      <input id="inputSpeed" type="number" value="70" min="10" max="130" step="1" class="form-input">
    </label>

    <label class="form-label">
      거리 (m)
      <input id="inputDist" type="number" value="200" min="10" max="900" step="1" class="form-input">
    </label>

    <label class="form-label">
      경사도 (%)
      <input id="inputGrade" type="number" value="0.0" min="-4" max="4" step="0.1" class="form-input">
    </label>

    <label class="form-label">
      날씨
      <select id="weatherSelect" class="form-input">
        <option value="맑음">맑음</option>
        <option value="비옴">비옴</option>
        <option value="눈옴">눈옴</option>
      </select>
    </label>

    <label class="form-label">
      승객 탑승률 (%)
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>

    <label class="form-label">
      편성
      <select class="form-input" id="trainLength" onchange="updateTrainLength()">
        <option value="4">4량</option>
        <option value="6">6량</option>
        <option value="8">8량</option>
        <option value="10">10량</option>
        <option value="11">11량</option><!-- E235-0/1000 등 -->
        <option value="12">12량</option>
        <option value="15">15량</option>
      </select>
    </label>

    <div class="game-background"></div>

    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay: 0s; left: 5%;"></div>
      <div style="animation-delay: 0.2s; left: 15%;"></div>
      <div style="animation-delay: 0.4s; left: 25%;"></div>
      <div style="animation-delay: 0.6s; left: 35%;"></div>
      <div style="animation-delay: 0.8s; left: 45%;"></div>
      <div style="animation-delay: 1s; left: 55%;"></div>
      <div style="animation-delay: 1.2s; left: 65%;"></div>
      <div style="animation-delay: 1.4s; left: 75%;"></div>
      <div style="animation-delay: 1.6s; left: 85%;"></div>
      <div style="animation-delay: 1.8s; left: 95%;"></div>
    </div>

    <div class="kbd-info">
      <span class="kbd">W</span> 브레이크 강화 · <span class="kbd">S</span> 완화 · <span class="kbd">N</span> 해방
    </div>

    <button id="btnStart" class="btn-primary">Start (Space)</button>
  </div>
</div>

<button id="btnMobileRestart" class="fab hide">재시작</button>

<script>
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});

function forceManualOverride() {
  if (tascToggle.checked) {
    tascToggle.checked = false;
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled: false } }));
    }
  }
}

/* 눈 */
const snowflakesContainer = document.querySelector('.snowflakes');
function generateSnowflake() {
  const f = document.createElement('div');
  const left = Math.floor(Math.random()*101);
  const delay = Math.random()*2;
  const dur = (Math.random()*5)+5;
  Object.assign(f.style, {
    animationDelay: delay+'s', animationDuration: dur+'s', left:left+'%', position:'absolute', top:'-10px',
    width:'10px', height:'10px', backgroundColor:'rgba(255,255,255,0.8)', borderRadius:'50%'
  });
  snowflakesContainer.appendChild(f);
  setTimeout(()=> snowflakesContainer.removeChild(f), (dur+delay)*1000);
}
setInterval(generateSnowflake, 200);

/* 차량 로딩 */
let vehicle = null;
let brakeDecels = {};

async function loadVehicle(jsonPath){
  try{
    const res = await fetch(jsonPath);
    const data = await res.json();
    vehicle = data;
    document.getElementById('carName').textContent = vehicle.name;

    brakeDecels = {};
    if (vehicle.notch_accels && vehicle.notches){
      for(let i=0; i<vehicle.notches; i++){
        brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
      }
    }
    sendLoadRate();

    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setVehicle", vehicle: vehicle.name }}));
    }
  }catch(e){ console.error(e); }
}

/* 열차군/시리즈 사전 & 기본 편성 매핑 */
const SERIES_BY_FAMILY = {
  E233: [
    {code:"E233-0",     file:"e233_0000.json",  defaultCars:10},
    {code:"E233-1000",  file:"e233_1000.json",  defaultCars:10},
    {code:"E233-2000",  file:"e233_2000.json",  defaultCars:10},
    {code:"E233-3000",  file:"e233_3000.json",  defaultCars:15},
    {code:"E233-5000",  file:"e233_5000.json",  defaultCars:10},
    {code:"E233-6000",  file:"e233_6000.json",  defaultCars:8},
    {code:"E233-7000",  file:"e233_7000.json",  defaultCars:10},
    {code:"E233-8000",  file:"e233_8000.json",  defaultCars:6}
  ],
  E235: [
    {code:"E235-0",     file:"e235_0.json",     defaultCars:11},
    {code:"E235-1000",  file:"e235_1000.json",  defaultCars:11}
  ]
};

function populateSeriesOptions(){
  const fam = document.getElementById('trainFamily').value;
  const sel = document.getElementById('trainSeries');
  sel.innerHTML = "";
  SERIES_BY_FAMILY[fam].forEach((s, idx)=>{
    const opt = document.createElement('option');
    opt.value = s.file;
    opt.textContent = `JR EAST ${s.code}`;
    if (idx===0) opt.selected = true;
    sel.appendChild(opt);
  });
  // 기본 편성 세팅
  const first = SERIES_BY_FAMILY[fam][0];
  document.getElementById('trainLength').value = String(first.defaultCars);
  // 해당 차량 로드
  loadVehicle(first.file);
}

document.getElementById('trainFamily').addEventListener('change', ()=>{
  populateSeriesOptions();
});

document.getElementById('trainSeries').addEventListener('change', (e)=>{
  const fam = document.getElementById('trainFamily').value;
  const file = e.target.value;
  // 선택된 시리즈의 기본 편성 반영
  const meta = SERIES_BY_FAMILY[fam].find(x=>x.file===file);
  if (meta) document.getElementById('trainLength').value = String(meta.defaultCars);
  loadVehicle(file);
});

/* 숫자 입력 강제 */
const remEl=document.getElementById("rem");
const spdEl=document.getElementById("spd");
const notchEl=document.getElementById("notch");
const fb=document.getElementById("fb");
const overlay=document.getElementById("overlay");
const btnStart=document.getElementById("btnStart");
const canvas=document.getElementById("hud");
const ctx=canvas.getContext("2d");

const weatherSelect = document.getElementById("weatherSelect");
const snowflakes = document.querySelector(".snowflakes");
const raindrops = document.querySelector(".raindrops");

function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; }
addEventListener("resize", resize); resize();

function sendCmd(name, delta) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}

function updateTrainLength() {
  const trainLength = document.getElementById("trainLength").value;
  ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setTrainLength", length: trainLength }}));
  sendLoadRate();
}

function sendLoadRate() {
  const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;
  const trainLength = parseInt(document.getElementById("trainLength").value) || 8;

  const baseMassPerCar = vehicle?.mass_t ?? 39.9;    // ★선택 차량 공차중량(ton/1량)
  const maxPassengerMassPerCar = 10.5;               // 가정치(만차 기준)

  const totalMassTons = trainLength * (baseMassPerCar + maxPassengerMassPerCar * (loadRate / 100));

  ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setMassTons", mass_tons: totalMassTons }}));
  console.log(`총 차량 중량: ${totalMassTons.toFixed(2)} t  (차종=${vehicle?.name}, 편성=${trainLength}량, 탑승률=${loadRate}%)`);
}

const inputSpeed = document.getElementById("inputSpeed");
const inputDist = document.getElementById("inputDist");
const inputGrade = document.getElementById("inputGrade");
const inputLoadRate = document.getElementById("inputLoadRate");

const clamp = (v,min,max)=> Math.min(max, Math.max(min, v));
function enforceInt(input,min,max){
  input.addEventListener('input', ()=>{ input.value = input.value.replace(/[^\d-]/g,''); });
  input.addEventListener('change', ()=>{ let v = parseInt(input.value,10); if(isNaN(v)){input.value='';return;} input.value = String(clamp(v,min,max)); });
}
function enforceFloat(input,min,max,digits=1){
  input.addEventListener('input', ()=>{ input.value = input.value.replace(/[^0-9.\-]/g,''); });
  input.addEventListener('change', ()=>{ let v = parseFloat(input.value); if(isNaN(v)){input.value='';return;} v = clamp(v,min,max); input.value = v.toFixed(digits); });
}

enforceInt(inputSpeed, 10, 130);
enforceInt(inputDist, 10, 900);
enforceInt(inputLoadRate, 0, 120);
enforceFloat(inputGrade, -4.0, 4.0, 1);

function muFromWeather(weather) {
  if (weather === "비옴") return 0.6;
  if (weather === "눈옴") return 0.3;
  return 1.0;
}

function startRun() {
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));

  const speed = Number(inputSpeed.value);
  const dist  = Number(inputDist.value);
  const grade = Number(inputGrade.value);
  const weather = weatherSelect.value;
  const mu = muFromWeather(weather);

  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setInitial", speed, dist, grade, mu } }));
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"start" }}));
  }

  overlay.classList.add("hide");
  isFinished = false;
  overlayShowingResult = false;
  document.getElementById("btnMobileRestart")?.classList.add("hide");
}
btnStart.addEventListener("click", startRun);

function updateWeatherUI(){
  const weather = weatherSelect.value;
  const overlayEl = document.getElementById("overlay");

  if (weather === "눈옴") {
    snowflakes.style.display = "block"; raindrops.style.display = "none";
    document.documentElement.style.background = "#ffffff";
    document.body.style.background = "#ffffff";
    overlayEl.style.background = "rgba(255,255,255,0.15)";
    canvas.style.background = "#ffffff";
  } else if (weather === "비옴") {
    snowflakes.style.display = "none"; raindrops.style.display = "block";
    document.documentElement.style.background = "#4b5d67";
    document.body.style.background = "#4b5d67";
    overlayEl.style.background = "rgba(40,60,80,0.35)";
    canvas.style.background = "#4b5d67";
  } else {
    snowflakes.style.display = "none"; raindrops.style.display = "none";
    const grad = "radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";
    document.documentElement.style.background = grad;
    document.body.style.background = grad;
    overlayEl.style.background = "rgba(0,0,0,0.6)";
    canvas.style.background = "linear-gradient(#0b0f14, #0a1019)";
  }
}
weatherSelect.addEventListener("change", ()=>{
  updateWeatherUI();
  const mu = muFromWeather(weatherSelect.value);
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setMu", value: mu }}));
  }
});
updateWeatherUI();

/* 시작 시 기본: E233 / E233-7000 / 10량 */
document.addEventListener('DOMContentLoaded', ()=>{
  populateSeriesOptions(); // E233 세트 채우고 첫 항목 로드
  const famSel = document.getElementById('trainFamily');
  const seriesSel = document.getElementById('trainSeries');
  const tl = document.getElementById('trainLength');

  // 기본값 강제(안전)
  famSel.value = "E233";
  populateSeriesOptions(); // 내부에서 차량도 로드함
  tl.value = "10";
  updateTrainLength();
});

/* 모바일 터치 브레이크 */
if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
  const gameSurface = document.getElementById("hud");
  gameSurface.addEventListener("touchstart", (e) => {
    if (!overlay.classList.contains("hide")) return;
    if (e.touches.length !== 1) return;
    forceManualOverride();
    const rect = gameSurface.getBoundingClientRect();
    const y = e.touches[0].clientY - rect.top;
    const half = rect.height / 2;
    if (y < half) sendCmd("applyNotch", +1);
    else sendCmd("applyNotch", -1);
  }, { passive: true });
}

/* HUD */
let prevMaxDistance = 0;
function drawHUD(st) {
  const dpr = devicePixelRatio || 1, w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const v0 = st.v;
  const lever = st.lever_notch;
  const currentPos = st.pos ?? 0;
  const stopPos = st.stopPos ?? 500;

  const remainingDistance = (typeof st.remaining_m === "number") ? Math.max(0, st.remaining_m) : Math.max(0, stopPos - currentPos);

  const minL = 1;
  const maxDecel = Math.max(...Object.values(brakeDecels));
  const maxStopDist = maxDecel > 0 ? (v0 * v0) / (2 * maxDecel) : 0;

  const speedFactor = Math.max(0.3, Math.min(1, v0 / 10)); 
  const adjustedRemaining = remainingDistance * (1 + (1 - speedFactor) * 0.5);
  const minX = 1;
  const safeRemaining = Math.max(minX, Math.sqrt(adjustedRemaining) * 10);
  const s_b1 = (brakeDecels[1] ?? 0) > 0 ? (v0 * v0) / (2 * brakeDecels[1]) : 0;
  const s_b2 = (brakeDecels[2] ?? 0) > 0 ? (v0 * v0) / (2 * brakeDecels[2]) : 0;

  const smoothFactor = 0.1;
  const targetMaxDistance = Math.max(minL, maxStopDist*1.5, safeRemaining*1.2, s_b1*1.1, s_b2*1.1);

  let maxDistance = prevMaxDistance===0 ? targetMaxDistance : prevMaxDistance*(1-smoothFactor)+targetMaxDistance*smoothFactor;
  prevMaxDistance = maxDistance;

  const leftMargin = 48 * dpr, rightMargin = 12 * dpr;
  const usableWidth = w - leftMargin - rightMargin;
  const X = dist => leftMargin + usableWidth * (dist / maxDistance);

  const vmax = Math.max(1, v0 * 3.6 * 1.2);
  const bottomMargin = 28 * dpr, topMargin = 12 * dpr;
  const usableHeight = h - bottomMargin - topMargin;
  const Y = v => h - bottomMargin - usableHeight * (v / vmax);

  ctx.strokeStyle = "#20334d";
  ctx.lineWidth = 1 * dpr;
  ctx.beginPath(); ctx.moveTo(leftMargin, topMargin); ctx.lineTo(leftMargin, h - bottomMargin); ctx.lineTo(w - rightMargin, h - bottomMargin); ctx.stroke();

  ctx.fillStyle = "#888"; ctx.font = `${10 * dpr}px sans-serif`; ctx.textAlign = "center"; ctx.textBaseline = "top";
  for (let dist = 0; dist <= maxDistance; dist += 100) {
    const x = X(dist);
    ctx.beginPath(); ctx.moveTo(x, h - bottomMargin); ctx.lineTo(x, h - bottomMargin + 4 * dpr); ctx.stroke();
    ctx.fillText(`${Math.round(dist)}`, x, h - bottomMargin + 6 * dpr);
  }

  ctx.textAlign = "right"; ctx.textBaseline = "middle";
  for (let speed_kmh = 0; speed_kmh <= vmax; speed_kmh += 10) {
    const y = Y(speed_kmh);
    ctx.beginPath(); ctx.moveTo(leftMargin - 4 * dpr, y); ctx.lineTo(leftMargin, y); ctx.stroke();
    ctx.fillText(`${speed_kmh}`, leftMargin - 6 * dpr, y);
  }

  ctx.lineWidth = 2 * dpr;
  const maxNotch = vehicle?.notches ?? 9;
  for(let notch = 0; notch < maxNotch; notch++) {
    const decel = brakeDecels[notch] ?? 0;
    if(decel <= 0) continue;
    const s_brake = (v0 * v0) / (2 * decel);

    ctx.beginPath();
    ctx.strokeStyle = notch === lever ? "#ffae00" : "#3fa9ff";
    for(let i=0; i<=100; i++) {
      const frac = i/100;
      const s = s_brake*frac;
      const v_cur = Math.sqrt(Math.max(0, v0*v0 - 2*decel*s));
      const x = X(s); const y = Y(v_cur*3.6);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.fillStyle = notch === lever ? "#ffae00" : "#3fa9ff";
    ctx.font = `${12 * dpr}px 'Orbitron', sans-serif`;
    const textX = X(s_brake);
    if (notch == 9) ctx.fillText(`EB`, textX + 5*dpr, Y(0) + 12*dpr);
    else if (notch == 0) ctx.fillText(`N`, textX + 5*dpr, Y(0) + 12*dpr);
    else ctx.fillText(`B${notch}`, textX + 5*dpr, Y(0) + 12*dpr);
  }

  const x_redline = X(remainingDistance);
  ctx.strokeStyle = "#ff0000"; ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath(); ctx.moveTo(x_redline, Y(0)); ctx.lineTo(x_redline, Y(vmax)); ctx.stroke();

  ctx.fillStyle = "#ff0000"; ctx.font = `${14 * dpr}px 'Orbitron', sans-serif`; ctx.textAlign = "center";
  ctx.fillText("남은 거리", x_redline, Y(vmax) - 18 * dpr);

  /* 사이드 리본/다이아 */
  const ribbonWidth = 16*dpr, ribbonHeight = h*0.9, ribbonX = w - rightMargin - ribbonWidth - 10*dpr + 20, ribbonY = ((h - ribbonHeight)/2) - 32;
  ctx.fillStyle = "rgba(100,100,100,0.1)"; ctx.strokeStyle = "rgba(100,100,100,0.3)"; ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath(); ctx.rect(ribbonX, ribbonY, ribbonWidth, ribbonHeight); ctx.fill(); ctx.stroke();

  const centerY = (ribbonY + ribbonHeight/2) - 14; const barHeight = 12*dpr;
  ctx.fillStyle = "rgba(60,60,60,0.9)"; ctx.fillRect(ribbonX + 2*dpr, centerY - barHeight/2, ribbonWidth - 4*dpr, barHeight);

  const L = st.L; const rem = Math.min(Math.max(st.remaining_m ?? L, -L), L);
  const topLimit = 7, bottomLimit = -7;
  const diamondWidth = 16*dpr, diamondHeight = 10*dpr;

  const diamondX = ribbonX + ribbonWidth/2;
  const normalizedRem = (rem - bottomLimit) / (topLimit - bottomLimit);
  const diamondY = ribbonY + (ribbonHeight * (1 - normalizedRem)) - diamondHeight/2;
  const overflowLimit = 10*dpr;
  const adjustedDiamondY = Math.min(Math.max(diamondY, ribbonY - overflowLimit), ribbonY + ribbonHeight - diamondHeight + overflowLimit);

  ctx.fillStyle = "#444"; ctx.strokeStyle = "#222"; ctx.lineWidth = 2*dpr;
  ctx.beginPath();
  ctx.moveTo(diamondX, adjustedDiamondY - diamondHeight/2);
  ctx.lineTo(diamondX + diamondWidth/2, adjustedDiamondY);
  ctx.lineTo(diamondX, adjustedDiamondY + diamondHeight/2);
  ctx.lineTo(diamondX - diamondWidth/2, adjustedDiamondY);
  ctx.closePath(); ctx.fill(); ctx.stroke();
}

let lastTimestamp = 0;
function loop(ts){
  if (!lastTimestamp) lastTimestamp = ts;
  lastTimestamp = ts;
  if (st) drawHUD(st);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

const grade_percentEl = document.getElementById("grade_percent");
const timerEl = document.getElementById("timer");
let isFinished = false;
let overlayShowingResult = false;
let st = null;

ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type === "state") {
    st = msg.payload;

    const remRaw = st.remaining_m;
    const rem = typeof remRaw === "number" ? remRaw : parseFloat(remRaw);

    remEl.textContent = rem >= 0 ? rem.toFixed(2) : `-${Math.abs(rem).toFixed(2)}`;
    spdEl.textContent = (st.v * 3.6).toFixed(1);

    function notchText(n){ if(n===0) return "N"; else if(n===9) return "EB"; else return `B${n}`; }
    notchEl.textContent = notchText(st.lever_notch);

    grade_percentEl.textContent = st.grade_percent.toFixed(2);
    timerEl.textContent = st.t.toFixed(3);
    drawHUD(st);

    if (st.finished) {
      isFinished = true;
      const issues = st.issues || {};
      const items = [
        { key:"early_brake_too_short", good:"초기 제동 수행 - 승차감 양호", bad:"초기 제동 미흡 - 승차감 저하" },
        { key:"stop_not_b1", good:"정차 시 B1로 제동 마무리", bad: issues.stop_not_b1_msg || "정차 시 B1 미준수" },
        { key:"step_brake_incomplete", good:"계단제동/완해 적정 수행", bad: (issues.stop_error_m<=-2) ? "계단제동 미흡 - 정차 초과" : "계단제동 미흡 - 승객 쏠림" },
        { key:"unnecessary_eb_usage", good:"EB 불필요 사용 없음", bad:"불필요 EB 사용" },
      ];
      const fbs = items.map(it=>{
        const bad = issues[it.key];
        return bad ? {text: it.bad, bad:true} : {text: it.good, good:true};
      });
      const within2m = Math.abs(st.stop_error_m||0) <= 2;
      fbs.push({text:`정지 오차: ${st.stop_error_m.toFixed(2)} m`, good: within2m});
      fbs.push({text:`최종 점수: ${st.score}점`, good: within2m});

      fb.innerHTML = fbs.map(x=> x.bad ? `<div class="bad">${x.text}</div>` : `<div class="${x.good?"ok":"warn"}">${x.text}</div>`).join("")
        + `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">Space로 다시 시작 · N 해방 · W/S로 조작</div>`;

      if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
        document.getElementById("btnMobileRestart").classList.remove("hide");
      }
    } else {
      isFinished = true;
      fb.textContent = "Space로 시작. W/S로 브레이크 조절하세요.";
    }
  }
};

document.getElementById("inputLoadRate").addEventListener("change", sendLoadRate);
</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  ©2025 Hyungsuk Choi, University of Maryland
</footer>
</body>
</html>