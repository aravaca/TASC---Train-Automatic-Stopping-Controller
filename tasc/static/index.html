<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
<style>
html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed; /* 스크롤 시 유지 */
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}

/* ⚠️ 삭제: 아래 규칙이 body에 붙은 클래스까지 투명 처리해 배경색 변경을 깨뜨렸음
.game-background,
.snow-background,
.rain-background {
  background: transparent !important;
}
*/

#wrap {
  max-width: 960px;
  margin: 18px auto;
  padding: 0 12px;
}

.row {
  display: flex;
  gap: 12px;
  align-items: center;
}

.card {
  background: rgba(18, 24, 38, 0.7);
  border: 1px solid rgba(0, 246, 255, 0.15);
  border-radius: 16px;
  padding: 16px;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 28px rgba(0,0,0,0.7);
}

canvas {
  width: 100%;
  height: 320px;
  background: linear-gradient(#0b0f14, #0a1019);
  border-radius: 12px;
}

.kbd {
  background: rgba(10, 18, 28, 0.8);
  border: 1px solid #2b3f5f;
  color: #9fc5ff;
  padding: 2px 6px;
  border-radius: 6px;
  font-size: 12px;
}

.stat {
  font-size: 32px;
  font-weight: 800;
  color: #ffffff;
  text-shadow: 0 0 4px rgba(0, 200, 255, 0.8);
}

.ok {
  color: #9effb5;
}
.warn {
  color: #ffd18f;
}
.bad {
  color: #ff9b9b;
}

button, .btn-primary {
  background: linear-gradient(135deg, #00c6ff, #0072ff);
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 10px 16px;
  font-size: 15px;
  font-weight: 600;
  transition: background 0.3s ease, transform 0.1s ease;
}
button:hover, .btn-primary:hover {
  background: linear-gradient(135deg, #0072ff, #00c6ff);
  transform: translateY(-1px);
}

#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(8px);
  z-index: 9999;
}

#overlay.hide {
  display: none;
}

.overlay-card {
  background: rgba(18, 24, 38, 0.9);
  padding: 24px 28px;
  border-radius: 14px;
  box-shadow: 0 0 20px rgba(0, 246, 255, 0.2);
  text-align: center;
  width: 300px;
  border: 1px solid rgba(0, 246, 255, 0.2);
}

.title {
  font-size: 1.4rem;
  font-weight: 600;
  margin-bottom: 4px;
  color: #00f6ff;
}

.subtitle {
  font-size: 0.9rem;
  color: #9fc5ff;
  margin-bottom: 16px;
}

.form-label {
  display: block;
  font-size: 0.85rem;
  margin-bottom: 12px;
  text-align: left;
  font-weight: 500;
  color: #cceaff;
}

.form-input {
  width: 95%;
  padding: 8px 10px;
  font-size: 0.9rem;
  border: 1px solid rgba(0, 246, 255, 0.3);
  border-radius: 8px;
  margin-top: 4px;
  background: rgba(10, 18, 28, 0.6);
  color: #e7f0ff;
}
.form-input:focus {
  border-color: #00f6ff;
  outline: none;
}

.kbd-info {
  margin: 16px 0;
  font-size: 0.85rem;
  color: #9fc5ff;
}

@keyframes neonGlow {
  0%, 100% {
    text-shadow:
      0 0 5px #fff,
      0 0 10px #fff,
      0 0 20px currentColor,
      0 0 30px currentColor,
      0 0 40px currentColor,
      0 0 55px currentColor,
      0 0 75px currentColor;
    opacity: 1;
  }
  50% {
    text-shadow:
      0 0 2px #fff,
      0 0 5px #fff,
      0 0 10px currentColor,
      0 0 15px currentColor,
      0 0 20px currentColor,
      0 0 30px currentColor,
      0 0 40px currentColor;
    opacity: 0.8;
  }
}

.grade-S, .grade-A {
  animation: neonGlow 2s ease-in-out infinite;
}

.grade-S {
  color: gold;
}
.grade-A {
  color: #4CAF50;
}

/* 눈 애니메이션 */
.snowflakes {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  display: none;
  overflow:hidden;
}

.snowflakes div {
  position: absolute;
  background-color: #fff;
  width: 10px;
  height:10px;
  border-radius: 50%;
  opacity: 0.8;
  animation: snow 5s linear infinite;
}

@keyframes snow {
  0% { transform: translateY(-20px); }
  100% { transform: translateY(100vh); }
}

/* 비 애니메이션 */
.raindrops {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9998;
  display: none;
  overflow:hidden;
}
.raindrops div {
  position: absolute;
  background-color: rgba(173, 216, 230, 0.8);
  width: 2px;
  height: 15px;
  animation: rain 0.5s linear infinite;
}
@keyframes rain {
  0% { transform: translateY(-20px); }
  100% { transform: translateY(100vh); }
}

/* 기본적으로 가로 스크롤은 막고, 세로는 허용 */
body {
  overflow-x: hidden;
  overflow-y: auto;
}

/* 모바일에서 스크롤 자연스럽게 + FAB에 가리지 않게 */
@media (max-width: 768px) {
  html, body { height: 100%; }
  body {
    -webkit-overflow-scrolling: touch; /* iOS 부드러운 스크롤 */
  }
  #wrap { padding-bottom: 96px; } /* 하단 FAB 공간 확보 */
  canvas#hud { height: 42vh; }    /* 모바일에서 캔버스 조금 줄임 */
}
.fab {
  position: fixed;
  left: 50%;
  bottom: 24px;
  transform: translateX(-50%);
  padding: 12px 18px;
  font-weight: 700;
  border-radius: 999px;
  background: linear-gradient(135deg, #00c6ff, #0072ff);
  color: #fff;
  border: none;
  z-index: 10000;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
}
.fab.hide { display: none; }
.fab:hover {
  background: linear-gradient(135deg, #0072ff, #00c6ff);
  transform: translateX(-50%) translateY(-1px);
}
.mobile-control-guide {
  display: none;
  font-size: 14px;
  color: #9fc5ff;
  background: rgba(18, 24, 38, 0.7);
  border: 1px solid rgba(0, 246, 255, 0.2);
  padding: 8px 12px;
  border-radius: 8px;
  margin-bottom: 12px;
}
@media (max-width: 768px) {
  .mobile-control-guide { display: block; }
}

/* 오른쪽 상단 고정 */
.tasc-toggle {
  position: absolute;
  top: 12px;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 1001;
}

/* 텍스트 라벨 */
.tasc-toggle .tasc-label {
  font-size: 12px;
  font-weight: 600;
  color: #9fc5ff;
  user-select: none;
}

/* 체크박스 숨기기 */
.tasc-toggle input { display: none; }

/* 토글 바탕 */
.tasc-toggle .slider {
  position: relative;
  display: inline-block;
  width: 46px;
  height: 24px;
  background-color: rgba(255, 255, 255, 0.25);
  border-radius: 24px;
  cursor: pointer;
  transition: background-color 0.3s;
  box-shadow: inset 0 0 4px rgba(0,0,0,0.3);
}

/* 동그라미 */
.tasc-toggle .slider::before {
  content: "";
  position: absolute;
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  border-radius: 50%;
  transition: transform 0.3s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}

/* 켜짐 상태 */
.tasc-toggle input:checked + .slider {
  background: linear-gradient(135deg, #00c6ff, #0072ff);
}
.tasc-toggle input:checked + .slider::before { transform: translateX(22px); }

</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

<div class="mobile-control-guide">
  📱 <b>모바일 조작 안내:</b> 캔버스(그래프) 위를 터치하세요.<br>
  위쪽 터치 → 브레이크 강화 🔼<br>
  아래쪽 터치 → 브레이크 완화 🔽<br>
  정차 후 아래 화면에서 피드백을 확인하세요.
</div>
    <div class="card" style="flex:1 1 260px">
      <div id="carName" style="font-size:20px" class = "stat">차량 로딩 중...</div>
      <div>남은 거리 <span class="stat" id="rem">—</span> m</div>
      <div>속도 <span class="stat" id="spd">—</span> km/h</div>
      <div>노치 <span class="stat" id="notch">0.0</span></div>
      <div>구배 <span class="stat" id="grade_percent">—</span> %</div>
      <div>경과시간 <span class="stat" id="timer">0.000</span> s</div>
      <div style="margin-top:8px">조작: <span class="kbd">Space</span> 시작 · <span class="kbd">W</span> 브레이크 강화(노치↑) · <span class="kbd">S</span> 완화(노치↓) · <span class="kbd">N</span> 해방</div>
    </div>

    <div class="card" style="flex:2 1 520px">
      <canvas id="hud"></canvas>
    </div>
    <div class="card" style="flex:1 1 240px">
      <div><b>피드백</b></div>
      <div id="fb">Space를 눌러 시작하세요.</div>
    </div>
  </div>
</div>

<!-- HTML -->
<div id="overlay">
  <div class="card">
<!-- TASC ON/OFF 토글 -->
<div class="tasc-toggle">
  <input type="checkbox" id="tascToggle" />
  <label for="tascToggle" class="slider"></label>
  <span class="tasc-label">TASC</span>
</div>

    <h2 class="title">🚉 TASC 기반 정차 트레이너</h2>
    <p class="subtitle">초기값을 입력하고 TASC(오토파일럿) 버튼을 활성화 혹은 비활성화 후 <b>Space</b> 또는 아래 버튼을 눌러 시작하세요.</p>

    <label class="form-label">
      초기 속도 (km/h)
      <input id="inputSpeed" type="number" value="90" min="40" max="120" step="10" class="form-input">
    </label>

    <label class="form-label">
      거리 (m)
      <input id="inputDist" type="number" value="500" min="200" max="800" step="100" class="form-input">
    </label>

    <label class="form-label">
      경사도 (%)
      <input id="inputGrade" type="number" value="0.0" min="-40" max="40" step="1" class="form-input">
    </label>

    <label class="form-label">
      날씨
      <select id="weatherSelect" class="form-input">
        <option value="맑음">맑음</option>
        <option value="비옴">비옴</option>
        <option value="눈옴">눈옴</option>
      </select>
    </label>
    <label class="form-label">
      승객 탑승률 (%)
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>


    <label class="form-label" for="trainLength">편성</label>
      <select class="form-input" id="trainLength" onchange="updateTrainLength()">
        <option value="4">4량 (JR 소부선 일부 구간)</option>
        <option value="6">6량 (JR 야마노테선, JR 치요다선, JR 소부선, JR 게이힌도호쿠선)</option>
        <option value="8">8량 (JR 도호쿠선, JR 요코스카선, JR 야마노테선, JR 게이힌도호쿠선)</option>
        <option value="10">10량 (JR 도호쿠선 일부 구간, JR 주오선 일부 구간)</option>
        <option value="12">12량 (JR 도호쿠선 주요 구간, JR 주오선 주요 구간)</option>
        <option value="15">15량 (JR 도호쿠선 일부 구간, 고속 노선)</option>
      </select>


    <!-- 게임 배경 -->
    <div class="game-background"></div>

    <!-- 눈 애니메이션 -->
    <div class="snowflakes"></div>

    <!-- 비 애니메이션 -->
    <div class="raindrops">
      <div style="animation-delay: 0s; left: 5%;"></div>
      <div style="animation-delay: 0.2s; left: 15%;"></div>
      <div style="animation-delay: 0.4s; left: 25%;"></div>
      <div style="animation-delay: 0.6s; left: 35%;"></div>
      <div style="animation-delay: 0.8s; left: 45%;"></div>
      <div style="animation-delay: 1s; left: 55%;"></div>
      <div style="animation-delay: 1.2s; left: 65%;"></div>
      <div style="animation-delay: 1.4s; left: 75%;"></div>
      <div style="animation-delay: 1.6s; left: 85%;"></div>
      <div style="animation-delay: 1.8s; left: 95%;"></div>
    </div>

    <div class="kbd-info">
      <span class="kbd">W</span> 브레이크 강화 · 
      <span class="kbd">S</span> 완화 · 
      <span class="kbd">N</span> 해방
    </div>

    <button id="btnStart" class="btn-primary">Start (Space)</button>
  </div>
</div>

<button id="btnMobileRestart" class="fab hide">재시작</button>
<script>
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});

function forceManualOverride() {
  if (tascToggle.checked) {
    tascToggle.checked = false;
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled: false } }));
    }
  }
}

const snowflakesContainer = document.querySelector('.snowflakes');

// 눈송이를 생성하는 함수
function generateSnowflake() {
  const snowflake = document.createElement('div');
  const randomLeft = Math.floor(Math.random() * 101);
  const animationDelay = Math.random() * 2;
  const animationDuration = (Math.random() * 5) + 5;

  snowflake.style.animationDelay = animationDelay + 's';
  snowflake.style.animationDuration = animationDuration + 's';
  snowflake.style.left = randomLeft + '%';

  snowflake.style.position = 'absolute';
  snowflake.style.top = '-10px';
  snowflake.style.width = '10px';
  snowflake.style.height = '10px';
  snowflake.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
  snowflake.style.borderRadius = '50%';

  snowflakesContainer.appendChild(snowflake);
  setTimeout(() => snowflakesContainer.removeChild(snowflake), (animationDuration + animationDelay) * 1000);
}
setInterval(generateSnowflake, 200);

let vehicle = null;
let brakeDecels = {};

fetch('/carName.json')
  .then(res => res.json())
  .then(data => {
    vehicle = data;
    document.getElementById('carName').textContent = vehicle.name;

    if (vehicle.notch_accels && vehicle.notches) {
      brakeDecels = {};
      for(let i=0; i < vehicle.notches; i++) {
        // 감속값 배열 반대 순서로 넣기
        brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
      }
    }
  })
  .catch(console.error);

const remEl=document.getElementById("rem");
const spdEl=document.getElementById("spd");
const notchEl=document.getElementById("notch");
const fb=document.getElementById("fb");
const overlay=document.getElementById("overlay");
const btnStart=document.getElementById("btnStart");
const canvas=document.getElementById("hud");
const ctx=canvas.getContext("2d");

const weatherSelect = document.getElementById("weatherSelect");
const snowflakes = document.querySelector(".snowflakes");
const raindrops = document.querySelector(".raindrops");

function resize(){
  canvas.width=canvas.clientWidth*devicePixelRatio;
  canvas.height=canvas.clientHeight*devicePixelRatio;
}
addEventListener("resize", resize); resize();

function sendCmd(name, delta) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}

function updateTrainLength() {
  const trainLength = document.getElementById("trainLength").value;
  ws.send(JSON.stringify({
      type: "cmd",
      payload: { name: "setTrainLength", length: trainLength }
  }));
  sendLoadRate();
}

function sendLoadRate() {
  const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;
  const trainLength = parseInt(document.getElementById("trainLength").value) || 8;

  const baseMassPerCar = 39.9;
  const maxPassengerMassPerCar = 10.5;

  const totalMassTons = trainLength * (baseMassPerCar + maxPassengerMassPerCar * (loadRate / 100));

  ws.send(JSON.stringify({
    type: "cmd",
    payload: { name: "setMassTons", mass_tons: totalMassTons }
  }));

  console.log(`총 차량 중량 업데이트: ${totalMassTons.toFixed(2)} 톤 (탑승률: ${loadRate}%)`);
}

const inputSpeed = document.getElementById("inputSpeed");
const inputDist = document.getElementById("inputDist");
const inputGrade = document.getElementById("inputGrade");

function muFromWeather(weather) {
  if (weather === "비옴") return 0.6;
  if (weather === "눈옴") return 0.3;
  return 1.0;
}

function startRun() {
  const speed = Number(inputSpeed.value);
  const dist  = Number(inputDist.value);
  const grade = Number(inputGrade.value);
  const weather = weatherSelect.value;
  const mu = muFromWeather(weather);

  if (ws.readyState === WebSocket.OPEN) {
    // ✅ 서버가 처리하는 setInitial에 mu 포함
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setInitial", speed, dist, grade, mu } }));
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "start" }}));
  }

  overlay.classList.add("hide");
  isFinished = false;
  overlayShowingResult = false;

  document.getElementById("btnMobileRestart")?.classList.add("hide");
}

btnStart.addEventListener("click", startRun);

function updateWeatherUI() {
  const weather = weatherSelect.value;
  const overlayEl = document.getElementById("overlay"); // ⬅ 추가

  if (weather === "눈옴") {
    snowflakes.style.display = "block";
    raindrops.style.display = "none";
    document.documentElement.style.background = "#ffffff";
    document.body.style.background = "#ffffff";
    overlayEl.style.background = "rgba(255,255,255,0.15)";   // ⬅ 추가(흰 기운)
  } else if (weather === "비옴") {
    raindrops.style.display = "block";
    snowflakes.style.display = "none";
    document.documentElement.style.background = "#4b5d67";
    document.body.style.background = "#4b5d67";
    overlayEl.style.background = "rgba(40,60,80,0.35)";      // ⬅ 추가(푸른 기운)
  } else {
    raindrops.style.display = "none";
    snowflakes.style.display = "none";
    const grad = "radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";
    document.documentElement.style.background = grad;
    document.body.style.background = grad;
    overlayEl.style.background = "rgba(0,0,0,0.6)";          // ⬅ 기본값
  }
}
weatherSelect.addEventListener("change", () => {
  updateWeatherUI(); // 배경/애니메이션
  const mu = muFromWeather(weatherSelect.value);
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setMu", value: mu } })); // ⬅ 추가 (핵심)
  }
});
updateWeatherUI(); // 초기 적용

const btnMobileRestart = document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", () => {
  overlay.classList.remove("hide");
  overlayShowingResult = true;
  btnMobileRestart.classList.add("hide");
});

addEventListener("keydown", (e) => {
  if ([" ", "w", "W", "s", "S", "n", "N"].includes(e.key)) e.preventDefault();
  if (e.repeat) return;

  forceManualOverride();

  if (e.key === " ") {
    if (ws.readyState !== WebSocket.OPEN) return;

    if (overlay.classList.contains("hide")) {
      if (isFinished) {
        overlay.classList.remove("hide");
        overlayShowingResult = true;
        isFinished = false;
      } else {
        const speed = Number(inputSpeed.value);
        const dist = Number(inputDist.value);
        const grade = Number(inputGrade.value);
        const mu = muFromWeather(weatherSelect.value);
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setInitial", speed, dist, grade, mu } }));
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "start" } }));
        isFinished = false;
        overlayShowingResult = false;
      }
    } else {
      overlay.classList.add("hide");
      const speed = Number(inputSpeed.value);
      const dist = Number(inputDist.value);
      const grade = Number(inputGrade.value);
      const mu = muFromWeather(weatherSelect.value);
      ws.send(JSON.stringify({ type: "cmd", payload: { name: "setInitial", speed, dist, grade, mu } }));
      ws.send(JSON.stringify({ type: "cmd", payload: { name: "start" } }));
      isFinished = false;
      overlayShowingResult = false;
    }
  } 
  else if (e.key === "w" || e.key === "W") {
    sendCmd("applyNotch", +1);
  }
  else if (e.key === "s" || e.key === "S") {
    sendCmd("applyNotch", -1);
  }
  else if (e.key === "n" || e.key === "N") {
    sendCmd("release", 0);
  }
});

if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
  const gameSurface = document.getElementById("hud");
  gameSurface.addEventListener("touchstart", (e) => {
    if (!overlay.classList.contains("hide")) return;
    if (e.touches.length !== 1) return;
    forceManualOverride();
    const rect = gameSurface.getBoundingClientRect();
    const y = e.touches[0].clientY - rect.top;
    const half = rect.height / 2;
    if (y < half) sendCmd("applyNotch", +1);
    else sendCmd("applyNotch", -1);
  }, { passive: true });
}

let prevMaxDistance = 0;

// HUD 그리기 (원본 유지)
function drawHUD(st) {
  const dpr = devicePixelRatio || 1, w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const v0 = st.v;
  const lever = st.lever_notch;
  const currentPos = st.pos ?? 0;
  const stopPos = st.stopPos ?? 500;

  const remainingDistance = (typeof st.remaining_m === "number") ? Math.max(0, st.remaining_m) : Math.max(0, stopPos - currentPos);

  const minL = 1;
  const maxDecel = Math.max(...Object.values(brakeDecels));
  const maxStopDist = maxDecel > 0 ? (v0 * v0) / (2 * maxDecel) : 0;

  const speedFactor = Math.max(0.3, Math.min(1, v0 / 10)); 
  const adjustedRemaining = remainingDistance * (1 + (1 - speedFactor) * 0.5);
  const minX = 1;
  const safeRemaining = Math.max(minX, Math.sqrt(adjustedRemaining) * 10);
  const s_b1 = (brakeDecels[1] ?? 0) > 0 ? (v0 * v0) / (2 * brakeDecels[1]) : 0;
  const s_b2 = (brakeDecels[2] ?? 0) > 0 ? (v0 * v0) / (2 * brakeDecels[2]) : 0;

  const isStart = remainingDistance > 0;

  const smoothFactor = 0.1;
  const targetMaxDistance = Math.max(
    minL,
    maxStopDist * 1.5,
    safeRemaining * 1.2,
    s_b1 * 1.1,
    s_b2 * 1.1
  );

  let maxDistance;
  if (prevMaxDistance === 0) maxDistance = targetMaxDistance;
  else maxDistance = prevMaxDistance * (1 - smoothFactor) + targetMaxDistance * smoothFactor;
  prevMaxDistance = maxDistance;

  const leftMargin = 48 * dpr;
  const rightMargin = 12 * dpr;
  const usableWidth = w - leftMargin - rightMargin;
  const X = dist => leftMargin + usableWidth * (dist / maxDistance);

  const vmax = Math.max(1, v0 * 3.6 * 1.2);

  const bottomMargin = 28 * dpr;
  const topMargin = 12 * dpr;
  const usableHeight = h - bottomMargin - topMargin;
  const Y = v => h - bottomMargin - usableHeight * (v / vmax);

  ctx.strokeStyle = "#20334d";
  ctx.lineWidth = 1 * dpr;
  ctx.beginPath();
  ctx.moveTo(leftMargin, topMargin);
  ctx.lineTo(leftMargin, h - bottomMargin);
  ctx.lineTo(w - rightMargin, h - bottomMargin);
  ctx.stroke();

  ctx.fillStyle = "#888";
  ctx.font = `${10 * dpr}px sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  for (let dist = 0; dist <= maxDistance; dist += 100) {
    const x = X(dist);
    ctx.beginPath();
    ctx.moveTo(x, h - bottomMargin);
    ctx.lineTo(x, h - bottomMargin + 4 * dpr);
    ctx.stroke();
    ctx.fillText(`${Math.round(dist)}`, x, h - bottomMargin + 6 * dpr);
  }

  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (let speed_kmh = 0; speed_kmh <= vmax; speed_kmh += 10) {
    const y = Y(speed_kmh);
    ctx.beginPath();
    ctx.moveTo(leftMargin - 4 * dpr, y);
    ctx.lineTo(leftMargin, y);
    ctx.stroke();
    ctx.fillText(`${speed_kmh}`, leftMargin - 6 * dpr, y);
  }

  ctx.lineWidth = 2 * dpr;
  const maxNotch = vehicle?.notches ?? 9;
  for(let notch = 0; notch < maxNotch; notch++) {
    const decel = brakeDecels[notch] ?? 0;
    if(decel <= 0) continue;

    const s_brake = (v0 * v0) / (2 * decel);

    ctx.beginPath();
    ctx.strokeStyle = notch === lever ? "#ffae00" : "#3fa9ff";

    for(let i=0; i<=100; i++) {
      const frac = i / 100;
      const s = s_brake * frac;
      const v_cur = Math.sqrt(Math.max(0, v0*v0 - 2*decel*s));
      const x = X(s);
      const y = Y(v_cur * 3.6);

      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = notch === lever ? "#ffae00" : "#3fa9ff";
    ctx.font = `${12 * dpr}px 'Orbitron', sans-serif`;
    const textX = X(s_brake);
    if (notch == 9) {
      ctx.fillText(`EB`, textX + 5 * dpr, Y(0) + 12 * dpr);
    } else if (notch == 0) {
      ctx.fillText(`N`, textX + 5 * dpr, Y(0) + 12 * dpr);
    } else{
      ctx.fillText(`B${notch}`, textX + 5 * dpr, Y(0) + 12 * dpr);
    }
  }

  const x_redline = X(remainingDistance);
  ctx.strokeStyle = "#ff0000";
  ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath();
  ctx.moveTo(x_redline, Y(0));
  ctx.lineTo(x_redline, Y(vmax));
  ctx.stroke();

  ctx.fillStyle = "#ff0000";
  ctx.font = `${14 * dpr}px 'Orbitron', sans-serif`;
  ctx.textAlign = "center";
  ctx.fillText("남은 거리", x_redline, Y(vmax) - 18 * dpr);

  // 우측 리본 및 다이아몬드 (원본 유지)
  const ribbonWidth = 16 * dpr;
  const ribbonHeight = h * 0.9;
  const ribbonX = w - rightMargin - ribbonWidth - 10 * dpr + 20;
  const ribbonY = ((h - ribbonHeight) / 2) - 12;

  ctx.fillStyle = "rgba(100, 100, 100, 0.1)";
  ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
  ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath();
  ctx.rect(ribbonX, ribbonY, ribbonWidth, ribbonHeight);
  ctx.fill();
  ctx.stroke();

  const centerY = (ribbonY + ribbonHeight / 2) - 5;
  const barHeight = 12 * dpr;
  ctx.fillStyle = "rgba(60, 60, 60, 0.9)";
  ctx.fillRect(ribbonX + 2 * dpr, centerY - barHeight / 2, ribbonWidth - 4 * dpr, barHeight);

  const ribbonTotalHeight = ribbonHeight;
  const L = st.L;
  const rem = Math.min(Math.max(st.remaining_m ?? L, -L), L);
  const topLimit = 7;
  const bottomLimit = -7;

  const diamondWidth = 16 * dpr;
  const diamondHeight = 10 * dpr;

  const stopErrorRaw = st.stop_error_m ?? 0;
  const stopErrorM = Math.max(-5, Math.min(5, stopErrorRaw));

  const diamondX = ribbonX + ribbonWidth / 2;
  const normalizedRem = (rem - bottomLimit) / (topLimit - bottomLimit);
  const diamondY = ribbonY + (ribbonHeight * (1 - normalizedRem)) - diamondHeight / 2;
  const overflowLimit = 10 * dpr;
  const adjustedDiamondY = Math.min(Math.max(diamondY, ribbonY - overflowLimit), ribbonY + ribbonHeight - diamondHeight + overflowLimit);

  ctx.fillStyle = "#444";
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 2 * dpr;
  ctx.beginPath();
  ctx.moveTo(diamondX, adjustedDiamondY - diamondHeight / 2);
  ctx.lineTo(diamondX + diamondWidth / 2, adjustedDiamondY);
  ctx.lineTo(diamondX, adjustedDiamondY + diamondHeight / 2);
  ctx.lineTo(diamondX - diamondWidth / 2, adjustedDiamondY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

// 애니메이션 루프
let lastTimestamp = 0;
function loop(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const dt = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;
  if (st) drawHUD(st);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

const grade_percentEl = document.getElementById("grade_percent");
const timerEl = document.getElementById("timer");

let isFinished = false;
let overlayShowingResult = false;
let st = null;
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type === "state") {
    st = msg.payload;

    const remRaw = st.remaining_m;
    const rem = typeof remRaw === "number" ? remRaw : parseFloat(remRaw);

    remEl.textContent = rem >= 0 ? rem.toFixed(2) : `-${Math.abs(rem).toFixed(2)}`;
    spdEl.textContent = (st.v * 3.6).toFixed(1);

    function notchText(notch) {
      if (notch === 0) return "N";
      else if (notch === 9) return "EB"; 
      else return `B${notch}`;
    }
    notchEl.textContent = notchText(st.lever_notch);

    grade_percentEl.textContent = st.grade_percent.toFixed(2);
    timerEl.textContent = st.t.toFixed(3);
    drawHUD(st);

    if (st.finished) {
      isFinished = true;
      const issues = st.issues || {};

      const feedbackItems = [
        { key: "early_brake_too_short", goodText: "초기 제동을 수행함 - 승차감 양호", badText: "초기 제동을 게을리함 - 승차감 불쾌" },
        {
          key: "stop_not_b1",
          goodText: "정차 시 B1로 정차함 - 승차감 양호",
          badTextFunc: (issues) => issues.stop_not_b1_msg || "정차 시 B1로 정차하지 않음",
        },
        {
          key: "step_brake_incomplete",
          goodText: "기본제동 (계단제동/완해) 수행함",
          badTextFunc: (issues) => {
            const overrun = issues.stop_error_m !== undefined && issues.stop_error_m <= -2;
            if (issues.stop_error_m !== undefined && issues.stop_error_m <= -2) {
              return "기본제동 (계단제동/완해) 미흡 - 정차 위치 초과 및 운행 지연 발생";
            }
            return "기본제동 (계단제동/완해) 미흡 - 단속적인 제동으로 인한 승객 쏠림 및 차량 진동 발생";
          },
        },
        { key: "unnecessary_eb_usage", goodText: "영업 안전 제동범위 준수", badText: "불필요한 비상제동(EB) 사용 - 급감속으로 인한 충격 발생" },
      ];

      const feedbacks = feedbackItems.map(item => {
        const bad = issues[item.key];
        if (!bad) return { text: item.goodText, isGood: true };
        const badText = item.badTextFunc ? item.badTextFunc(issues) : item.badText;
        return { text: badText, isGood: false, isBad: true };
      });

      const isStopErrorGood = Math.abs(st.stop_error_m || 0) <= 2;

      feedbacks.push({
        text: `정지 오차: ${st.stop_error_m.toFixed(2)} m`,
        isGood: isStopErrorGood,
      });

      feedbacks.push({
        text: `최종 점수: ${st.score}점`,
        isGood: isStopErrorGood,
      });

      fb.innerHTML = feedbacks
        .map(item => item.isBad
          ? `<div class="bad">${item.text}</div>`
          : `<div class="${item.isGood ? "ok" : "warn"}">${item.text}</div>`
        )
        .join("") + `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">Space로 다시 시작 · N 해방 · W/S로 조작</div>`;

      if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
        document.getElementById("btnMobileRestart").classList.remove("hide");
      }
    } else {
      isFinished = true;
      fb.textContent = "Space로 시작. W/S로 브레이크 조절하세요.";
    }
  }
};

document.getElementById("inputLoadRate").addEventListener("change", sendLoadRate);
</script>
<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  ©2025 Hyungsuk Choi, University of Maryland
</footer>

</body>
</html>